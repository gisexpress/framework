//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Linq;
using System.Xml;

namespace System.ComponentModel
{
    public class PropertyNode : PropertyDescriptor<IPropertyCollection>
    {
        public PropertyNode()
            : base("String", Types.String)
        {
        }

        public PropertyNode(string name, Type type, params Attribute[] attributes)
            : base(name, type, attributes)
        {
        }

        public string PropertyName
        {
            get { return base.Name; }
            set { Property.Name = value; }
        }

        public string PropertyTypeName
        {
            get
            {
                if (!HasChildren)
                {
                    if (!PropertyType.IsEnum && PropertyTypeCode.IsWellKnownType())
                    {
                        return Enums.GetName(PropertyTypeCode);
                    }

                    return PropertyType.AssemblyQualifiedName;
                }

                return null;
            }
            set
            {
                TypeCode code;

                if (Enum.TryParse(value, true, out code))
                {
                    Property.PropertyType = code.GetRuntimeType();
                }
                else
                {
                    Property.PropertyType = Type.GetType(value.Split(',').FirstOrDefault(), false) ?? Type.GetType(value, false);
                }
            }
        }

        //public string PropertyValue
        //{
        //    get
        //    {
        //        if (Value.IsNullOrEmpty() || HasChildren)
        //        {
        //            return default(string);
        //        }

        //        return Value.ToInvariantString(PropertyType, PropertyTypeCode);
        //    }
        //    set
        //    {
        //        Value = value.ParseInvariantString(PropertyType, PropertyTypeCode);
        //    }
        //}

        protected new PropertyNodeCollection ChildProperties
        {
            get { return (PropertyNodeCollection)base.ChildProperties; }
        }

        public override object GetValue(object component)
        {
            if (HasChildren)
            {
                return Items;
            }

            //var properties = component as IPropertyCollection;

            //if (properties.HasValue())
            //{
            //    IPropertyDescriptor property = properties[Name];

            //    if (property.HasValue())
            //    {
            //        return property.Value;
            //    }
            //}

            return Value ?? (component as IPropertyGetter).Get(Name);
        }

        public override void SetValue(object component, object value)
        {
            //var collection = component as IPropertyCollection;

            //if (collection == null)
            //{
                Value = value;
                OnValueChanged(this);
            //}
            //else
            //{
            //    IPropertyDescriptor property = collection[Name];

            //    if (property == null)
            //    {
            //        return;
            //    }

            //    property.Value = value;
            //    OnValueChanged(property);
            //}
        }

        public void LoadXml(XmlNode node)
        {
            //foreach (string name in reader.ReadElements("Property"))
            //{
            //    switch (name)
            //    {
            //        case "Category":
            //            Property.Category = reader.ReadString();
            //            break;
            //        case "PropertyName":
            //            PropertyName = reader.ReadString();
            //            break;
            //        case "PropertyTypeName":
            //            PropertyTypeName = reader.ReadString();
            //            break;
            //        case "PropertyValue":
            //            if (Types.IXmlSerializable.IsAssignableFrom(Property.PropertyType))
            //            {
            //                var serializable = (Property.Value = Property.Value ?? Activator.CreateInstance(Property.PropertyType, true)) as IXmlSerializable;

            //                if (serializable.HasValue())
            //                {
            //                    serializable.ReadXml(reader);
            //                }
            //            }
            //            else
            //            {
            //                PropertyValue = reader.ReadString();
            //            }
            //            break;
            //        case "ChildProperties":
            //            ChildProperties.ReadXml(reader);
            //            break;
            //    }
            //}
        }

        public void WriteXml(XmlWriter writer)
        {
            //writer.WriteStartElement("property");

            //writer.WriteElement("category", Category);
            //writer.WriteElement("name", PropertyName);
            //writer.WriteElement("typeName", PropertyTypeName);

            //if (Types.IXmlSerializable.IsAssignableFrom(Property.PropertyType))
            //{
            //    var serializable = Property.Value as IXmlSerializable;

            //    if (serializable.HasValue())
            //    {
            //        writer.WriteStartElement("value");
            //        serializable.WriteXml(writer);
            //        writer.WriteEndElement();
            //    }
            //}
            //else
            //{
            //    writer.WriteElement("value", PropertyValue);
            //}

            //if (HasChildren)
            //{
            //    writer.WriteStartElement("childs");
            //    ChildProperties.WriteXml(writer);
            //    writer.WriteEndElement();
            //}

            //writer.WriteEndElement();
        }
    }
}
