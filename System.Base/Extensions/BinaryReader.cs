//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Runtime.InteropServices;

namespace System.IO
{
    public static class BinaryReaderExtensions
    {
        public static BinaryReader OpenRead(string path)
        {
            return Open(File.OpenRead(path));
        }

        public static BinaryReader Open(Stream input)
        {
            return new BinaryReader(input.Open(), Constants.UTF8);
        }

        public static bool CanRead(this BinaryReader reader)
        {
            return reader.BaseStream.Position < reader.BaseStream.Length;
        }

        public static void Reset(this BinaryReader reader)
        {
            reader.BaseStream.Position = 0;
        }

        public static void Goto(this BinaryReader reader, long position)
        {
            reader.BaseStream.Position = position;
        }

        public static void Forward(this BinaryReader reader, long value)
        {
            reader.BaseStream.Position += value;
        }

        public static DateTime ReadDateTime(this BinaryReader reader)
        {
            return DateTime.FromBinary(reader.ReadInt64());
        }

        public static Guid ReadGuid(this BinaryReader reader)
        {
            return new Guid(reader.ReadBytes(16));
        }

        public static object ReadValue(this BinaryReader reader, TypeCode type)
        {
            switch (type)
            {
                case TypeCode.Byte:
                    return reader.ReadByte();
                case TypeCode.SByte:
                    return reader.ReadSByte();
                case TypeCode.Boolean:
                    return reader.ReadBoolean();
                case TypeCode.Char:
                    return reader.ReadChar();
                case TypeCode.Single:
                    return reader.ReadSingle();
                case TypeCode.Decimal:
                    return reader.ReadDecimal();
                case TypeCode.Double:
                    return reader.ReadDouble();
                case TypeCode.Int16:
                    return reader.ReadInt16();
                case TypeCode.Int32:
                    return reader.ReadInt32();
                case TypeCode.Int64:
                    return reader.ReadInt64();
                case TypeCode.UInt16:
                    return reader.ReadUInt16();
                case TypeCode.UInt32:
                    return reader.ReadUInt32();
                case TypeCode.UInt64:
                    return reader.ReadUInt64();
                case TypeCode.String:
                    return reader.ReadString();
                case TypeCode.DateTime:
                    return reader.ReadDateTime();
            }

            throw new NotImplementedException();
        }

        public static int ReadBigEndianInt32(this BinaryReader reader)
        {
            var byteArray = new byte[4];
            reader.Read(byteArray, 0, 4);
            Array.Reverse(byteArray);
            return BitConverter.ToInt32(byteArray, 0);
        }

        public static double ReadBigEndianDouble(this BinaryReader reader)
        {
            var byteArray = new byte[8];
            reader.Read(byteArray, 0, 8);
            Array.Reverse(byteArray);
            return BitConverter.ToDouble(byteArray, 0);
        }

        public static int[] ReadInt32Array(this BinaryReader reader, int length)
        {
            var arr = new int[length];

            for (int n = 0; n < length; n++)
            {
                arr[n] = reader.ReadInt32();
            }

            return arr;
        }

        public static double[] ReadDoubleArray(this BinaryReader reader, int length)
        {
            var arr = new double[length];

            for (int n = 0; n < length; n++)
            {
                arr[n] = reader.ReadDouble();
            }

            return arr;
        }

        public static object ReadValueType(this BinaryReader reader, Type structureType)
        {
            return ToObject(reader.ReadBytes(Marshal.SizeOf(structureType)), structureType);
        }

        public static object ToObject(this byte[] value, Type structureType)
        {
            var ptr = IntPtr.Zero;

            try
            {
                ptr = Marshal.AllocHGlobal(value.Length);
                Marshal.Copy(value, 0, ptr, value.Length);
                return Marshal.PtrToStructure(ptr, structureType);
            }
            finally
            {
                Marshal.FreeHGlobal(ptr);
            }
        }
    }
}
