//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Globalization;
using System.Text;

namespace System
{
    public struct DeterminantDouble : IComparable, IComparable<DeterminantDouble>
    {
        const double Split = 134217729.0;

        readonly double Hi;
        readonly double Lo;

        static readonly DeterminantDouble NaN = new DeterminantDouble(Double.NaN, Double.NaN);

        public DeterminantDouble(double x)
            : this(x, 0d)
        {
        }

        public DeterminantDouble(double hi, double lo)
        {
            Hi = hi;
            Lo = lo;
        }

        public DeterminantDouble(DeterminantDouble value)
        {
            Hi = value.Hi;
            Lo = value.Lo;
        }

        public static DeterminantDouble ValueOf(double value)
        {
            return new DeterminantDouble(value);
        }

        public static implicit operator DeterminantDouble(double value)
        {
            return ValueOf(value);
        }

        public static DeterminantDouble operator +(DeterminantDouble left, DeterminantDouble right)
        {
            double H, h, T, t, S, s, e, f;

            S = left.Hi + right.Hi;
            T = left.Lo + right.Lo;
            e = S - left.Hi;
            f = T - left.Lo;
            s = S - e;
            t = T - f;
            s = (right.Hi - e) + (left.Hi - s);
            t = (right.Lo - f) + (left.Lo - t);
            e = s + T;
            H = S + e;
            h = e + (S - H);
            e = t + h;

            double zhi = H + e;

            return new DeterminantDouble(zhi, e + (H - zhi));
        }

        public static DeterminantDouble operator +(DeterminantDouble left, Double right)
        {
            return left + new DeterminantDouble(right, 0);
        }

        public static DeterminantDouble operator -(DeterminantDouble left, DeterminantDouble right)
        {
            return left + right.Negate();
        }

        public static DeterminantDouble operator -(DeterminantDouble left, Double right)
        {
            return left + new DeterminantDouble(-right, 0);
        }

        public DeterminantDouble Negate()
        {
            if (IsNaN(this)) return this;
            return new DeterminantDouble(-Hi, -Lo);
        }

        public static DeterminantDouble operator *(DeterminantDouble left, Double right)
        {
            return left * new DeterminantDouble(right, 0.0);
        }

        public static DeterminantDouble operator *(DeterminantDouble left, DeterminantDouble right)
        {
            if (IsNaN(right)) return NaN;

            double C = Split * left.Hi;
            double hx = C - left.Hi;
            double c = Split * right.Hi;
            hx = C - hx;
            double tx = left.Hi - hx;
            double hy = c - right.Hi;
            C = left.Hi * right.Hi;
            hy = c - hy;
            double ty = right.Hi - hy;
            c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (left.Hi * right.Lo + left.Lo * right.Hi);
            double zhi = C + c;
            hx = C - zhi;
            double zlo = c + hx;

            return new DeterminantDouble(zhi, zlo);
        }

        public DeterminantDouble Divide(DeterminantDouble y)
        {
            double hc, tc, hy, ty, C, c, U, u;
            C = Hi / y.Hi;
            c = Split * C;
            hc = c - C;
            u = Split * y.Hi;
            hc = c - hc;
            tc = C - hc;
            hy = u - y.Hi;
            U = C * y.Hi;
            hy = u - hy;
            ty = y.Hi - hy;
            u = (((hc * hy - U) + hc * ty) + tc * hy) + tc * ty;
            c = ((((Hi - U) - u) + Lo) - C * y.Lo) / y.Hi;
            u = C + c;

            double zhi = u;
            double zlo = (C - u) + c;
            return new DeterminantDouble(zhi, zlo);
        }

        public static DeterminantDouble operator /(DeterminantDouble left, Double right)
        {
            return left / new DeterminantDouble(right, 0d);
        }

        public static DeterminantDouble operator /(DeterminantDouble left, DeterminantDouble right)
        {
            if (IsNaN(right)) return NaN;

            double hc, tc, hy, ty, C, c, U, u;
            C = left.Hi / right.Hi;
            c = Split * C;
            hc = c - C;
            u = Split * right.Hi;
            hc = c - hc;
            tc = C - hc;
            hy = u - right.Hi;
            U = C * right.Hi;
            hy = u - hy;
            ty = right.Hi - hy;
            u = (((hc * hy - U) + hc * ty) + tc * hy) + tc * ty;
            c = ((((left.Hi - U) - u) + left.Lo) - C * right.Lo) / right.Hi;
            u = C + c;

            return new DeterminantDouble(u, (C - u) + c);
        }

        public DeterminantDouble Reciprocal()
        {
            double hc, tc, hy, ty, C, c, U, u;
            C = 1.0 / Hi;
            c = Split * C;
            hc = c - C;
            u = Split * Hi;
            hc = c - hc;
            tc = C - hc;
            hy = u - Hi;
            U = C * Hi;
            hy = u - hy;
            ty = Hi - hy;
            u = (((hc * hy - U) + hc * ty) + tc * hy) + tc * ty;
            c = ((((1.0 - U) - u)) - C * Lo) / Hi;

            double zhi = C + c;
            double zlo = (C - zhi) + c;

            return new DeterminantDouble(zhi, zlo);
        }

        public DeterminantDouble Min(DeterminantDouble x)
        {
            return LessThan(x) ? this : x;
        }

        public DeterminantDouble Max(DeterminantDouble x)
        {
            return GreaterOrEqualThan(x) ? this : x;
        }

        public DeterminantDouble Floor()
        {
            if (IsNaN(this)) return NaN;
            double fhi = Math.Floor(Hi);
            double flo = 0.0;
            // Hi is already integral.  Floor the low word
            if (fhi == Hi)
            {
                flo = Math.Floor(Lo);
            }
            // do we need to renormalize here?
            return new DeterminantDouble(fhi, flo);
        }

        /// <summary>
        /// Returns the absolute value of this value.
        /// <para/>
        /// Special cases:
        /// <list type="Bullet">
        /// <item>if this value is NaN, it is returned.</item>
        /// </list>
        /// </summary>
        /// <returns>The absolute value of this value</returns>
        public DeterminantDouble Abs()
        {
            if (IsNaN(this)) return NaN;
            return IsNegative ? Negate() : new DeterminantDouble(this);
        }

        /// <summary>
        /// Computes the square of this value.
        /// </summary>
        /// <returns>The square of this value</returns>
        public DeterminantDouble Sqr()
        {
            return this * this;
        }

        public static DeterminantDouble Sqr(double x)
        {
            return ValueOf(x) * x;
        }

        public DeterminantDouble Sqrt()
        {
            if (IsZero)
            {
                return ValueOf(0.0);
            }

            if (IsNegative)
            {
                return NaN;
            }

            double x = 1.0 / Math.Sqrt(Hi);
            double ax = Hi * x;

            var axdd = ValueOf(ax);
            var diffSq = this - axdd.Sqr();
            var d2 = diffSq.Hi * (x * 0.5);

            return axdd + d2;
        }

        public DeterminantDouble Pow(int exp)
        {
            if (exp == 0.0)
                return ValueOf(1.0);

            DeterminantDouble r = new DeterminantDouble(this);
            DeterminantDouble s = ValueOf(1.0);
            int n = Math.Abs(exp);

            if (n > 1)
            {
                /* Use binary exponentiation */
                while (n > 0)
                {
                    if (n % 2 == 1)
                    {
                        s *= r;
                    }
                    n /= 2;
                    if (n > 0)
                        r = r.Sqr();
                }
            }
            else
            {
                s = r;
            }

            /* Compute the reciprocal if n is negative. */
            if (exp < 0)
                return s.Reciprocal();
            return s;
        }

        public double ToDoubleValue()
        {
            return Hi + Lo;
        }

        public int ToIntValue()
        {
            return (int)Hi;
        }

        public bool IsZero
        {
            get { return Hi == 0.0 && Lo == 0.0; }
        }

        /// <summary>
        /// Gets a value indicating whether this object is negative or not
        /// </summary>
        public bool IsNegative
        {
            get { return Hi < 0.0 || (Hi == 0.0 && Lo < 0.0); }
        }

        /// <summary>
        /// Gets a value indicating whether this object is positive or not
        /// </summary>
        public bool IsPositive()
        {
            return Hi > 0.0 || (Hi == 0.0 && Lo > 0.0);
        }

        /// <summary>
        /// Gets a value indicating whether this object is positive or not
        /// </summary>
        public static bool IsNaN(DeterminantDouble value)
        {
            return Double.IsNaN(value.Hi);
        }

        public bool Equals(DeterminantDouble y)
        {
            return y.Hi.Equals(Hi) && y.Lo.Equals(Lo);
        }

        public static bool operator ==(DeterminantDouble left, DeterminantDouble right)
        {
            return left.Hi == right.Hi && left.Lo == right.Lo;
        }

        public static bool operator !=(DeterminantDouble right, DeterminantDouble left)
        {
            return !(right == left);
        }

        public bool GreaterThan(DeterminantDouble y)
        {
            return (Hi > y.Hi) || (Hi == y.Hi && Lo > y.Lo);
        }

        public bool GreaterOrEqualThan(DeterminantDouble y)
        {
            return (Hi > y.Hi) || (Hi == y.Hi && Lo >= y.Lo);
        }

        /// <summary>
        /// Tests whether this value is less than another <tt>DoubleDouble</tt> value.
        /// </summary>
        /// <param name="y">A DoubleDouble value</param>
        /// <returns><c>true</c> if this value is &lt; <paramref name="y"/> </returns>
        public bool LessThan(DeterminantDouble y)
        {
            return (Hi < y.Hi) || (Hi == y.Hi && Lo < y.Lo);
        }

        /**
         * Tests whether this value is less than or equal to another <tt>DoubleDouble</tt> value.
         * @param y a DoubleDouble value
         * @return true if this value <= y
         */

        public bool LessOrEqualThan(DeterminantDouble y)
        {
            return (Hi < y.Hi) || (Hi == y.Hi && Lo <= y.Lo);
        }

        /**
         * Compares two DoubleDouble objects numerically.
         * 
         * @return -1,0 or 1 depending on whether this value is less than, equal to
         * or greater than the value of <tt>o</tt>
         */

        public int CompareTo(DeterminantDouble other)
        {
            if (Hi < other.Hi) return -1;
            if (Hi > other.Hi) return 1;
            if (Lo < other.Lo) return -1;
            if (Lo > other.Lo) return 1;
            return 0;
        }

        public int CompareTo(Object o)
        {
            var other = (DeterminantDouble)o;

            if (Hi < other.Hi) return -1;
            if (Hi > other.Hi) return 1;
            if (Lo < other.Lo) return -1;
            if (Lo > other.Lo) return 1;
            return 0;
        }


        /*------------------------------------------------------------
         *   Output
         *------------------------------------------------------------
         */

        private const int MaxPrintDigits = 32;
        private static readonly DeterminantDouble Ten = ValueOf(10.0);
        private static readonly DeterminantDouble One = ValueOf(1.0);
        private static readonly String SCI_NOT_EXPONENT_CHAR = "E";
        private static readonly String SCI_NOT_ZERO = "0.0E0";

        /// <summary>
        /// Dumps the components of this number to a string.
        /// </summary>
        /// <returns>A string showing the components of the number</returns>
        public String Dump()
        {
            return string.Format(NumberFormatInfo.InvariantInfo, "DD<{0}, {1}>", Hi, Lo);
        }

        /// <summary>
        /// Returns a string representation of this number, in either standard or scientific notation.
        /// If the magnitude of the number is in the range [ 10<sup>-3</sup>, 10<sup>8</sup> ]
        /// standard notation will be used.  Otherwise, scientific notation will be used.
        /// </summary>
        /// <returns>A string representation of this number</returns>
        public override String ToString()
        {
            var mag = Magnitude(Hi);
            if (mag >= -3 && mag <= 20)
                return ToStandardNotation();
            return ToSciNotation();
        }

        /// <summary>
        /// Returns the string representation of this value in standard notation.
        /// </summary>
        /// <returns>The string representation in standard notation</returns>
        public String ToStandardNotation()
        {
            var specialStr = GetSpecialNumberString();

            if (specialStr.HasValue())
            {
                return specialStr;
            }

            var magnitude = new int[1];
            var sigDigits = ExtractSignificantDigits(true, magnitude);
            int decimalPointPos = magnitude[0] + 1;

            String num = sigDigits;
            // add a leading 0 if the decimal point is the first char
            if (sigDigits[0] == '.')
            {
                num = "0" + sigDigits;
            }
            else if (decimalPointPos < 0)
            {
                num = "0." + new string('0', -decimalPointPos) + sigDigits;
            }
            else if (sigDigits.IndexOf('.') == -1)
            {
                // no point inserted - sig digits must be smaller than magnitude of number
                // add zeroes to end to make number the correct size
                int numZeroes = decimalPointPos - sigDigits.Length;
                var zeroes = new string('0', numZeroes);
                num = sigDigits + zeroes + ".0";
            }

            if (IsNegative)
                return "-" + num;
            return num;
        }

        /// <summary>
        /// Returns the string representation of this value in scientific notation.
        /// </summary>
        /// <returns>The string representation in scientific notation</returns>
        public String ToSciNotation()
        {
            // special case zero, to allow as
            if (IsZero)
                return SCI_NOT_ZERO;

            string specialStr = GetSpecialNumberString();
            
            if (specialStr.HasValue())
            {
                return specialStr;
            }

            int[] magnitude = new int[1];
            String digits = ExtractSignificantDigits(false, magnitude);
            String expStr = SCI_NOT_EXPONENT_CHAR + magnitude[0];

            // should never have leading zeroes
            // MD - is this correct?  Or should we simply strip them if they are present?
            if (digits[0] == '0')
            {
                throw new InvalidOperationException("Found leading zero: " + digits);
            }

            // add decimal point
            String trailingDigits = "";
            if (digits.Length > 1)
                trailingDigits = digits.Substring(1);
            String digitsWithDecimal = digits[0] + "." + trailingDigits;

            if (IsNegative)
                return "-" + digitsWithDecimal + expStr;
            return digitsWithDecimal + expStr;
        }


        /**
         * Extracts the significant digits in the decimal representation of the argument.
         * A decimal point may be optionally inserted in the string of digits
         * (as long as its position lies within the extracted digits
         * - if not, the caller must prepend or append the appropriate zeroes and decimal point).
         * 
         * @param y the number to extract ( >= 0)
         * @param decimalPointPos the position in which to insert a decimal point
         * @return the string containing the significant digits and possibly a decimal point
         */

        private String ExtractSignificantDigits(bool insertDecimalPoint, int[] magnitudes)
        {
            var y = this.Abs();
            // compute *correct* magnitude of y
            var mag = Magnitude(y.Hi);
            var scale = Ten.Pow(mag);
            y /= scale;

            // fix magnitude if off by one
            if (y.GreaterThan(Ten))
            {
                y /= Ten;
                mag += 1;
            }
            else if (y.LessThan(One))
            {
                y *= Ten;
                mag -= 1;
            }

            int decimalPointPos = mag + 1;
            var buf = new StringBuilder();
            int numDigits = MaxPrintDigits - 1;
            for (int i = 0; i <= numDigits; i++)
            {
                if (insertDecimalPoint && i == decimalPointPos)
                {
                    buf.Append('.');
                }
                int digit = (int)y.Hi;
                //      System.out.println("printDump: [" + i + "] digit: " + digit + "  y: " + y.dump() + "  buf: " + buf);

                /**
                 * This should never happen, due to heuristic checks on remainder below
                 */
                if (digit < 0 || digit > 9)
                {
                    //        System.out.println("digit > 10 : " + digit);
                    //        throw new IllegalStateException("Internal errror: found digit = " + digit);
                }
                /**
                 * If a negative remainder is encountered, simply terminate the extraction.  
                 * This is robust, but maybe slightly inaccurate.
                 * My current hypothesis is that negative remainders only occur for very small lo components, 
                 * so the inaccuracy is tolerable
                 */
                if (digit < 0)
                {
                    break;
                    // throw new IllegalStateException("Internal errror: found digit = " + digit);
                }
                bool rebiasBy10 = false;
                char digitChar;
                if (digit > 9)
                {
                    // set flag to re-bias after next 10-shift
                    rebiasBy10 = true;
                    // output digit will end up being '9'
                    digitChar = '9';
                }
                else
                {
                    digitChar = (char)('0' + digit);
                }
                buf.Append(digitChar);
                y = (y - ValueOf(digit)) * Ten;
                if (rebiasBy10)
                    y += Ten;

                bool continueExtractingDigits = true;
                /**
                 * Heuristic check: if the remaining portion of 
                 * y is non-positive, assume that output is complete
                 */
                //      if (y.hi <= 0.0)
                //        if (y.hi < 0.0)
                //        continueExtractingDigits = false;
                /**
                 * Check if remaining digits will be 0, and if so don't output them.
                 * Do this by comparing the magnitude of the remainder with the expected precision.
                 */
                int remMag = Magnitude(y.Hi);
                if (remMag < 0 && Math.Abs(remMag) >= (numDigits - i))
                    continueExtractingDigits = false;
                if (!continueExtractingDigits)
                    break;
            }
            magnitudes[0] = mag;
            return buf.ToString();
        }

        /// <summary>
        /// Returns the string for this value if it has a known representation (e.g. NaN or 0.0).
        /// </summary>
        /// <returns>The string for this special number <br/>
        /// or <c>null</c> if the number is not a special number</returns>
        private String GetSpecialNumberString()
        {
            if (IsZero) return "0.0";
            if (IsNaN(this)) return "NaN ";
            return null;
        }

        /// <summary>
        /// Determines the decimal magnitude of a number.<para/>
        /// The magnitude is the exponent of the greatest power of 10 which is less than
        /// or equal to the number.
        /// </summary>
        /// <param name="x">The number to find the magnitude of</param>
        /// <returns>The decimal magnitude of <paramref name="x"/></returns>
        private static int Magnitude(double x)
        {
            var xAbs = Math.Abs(x);
            var xLog10 = Math.Log(xAbs) / Math.Log(10);
            var xMag = (int)Math.Floor(xLog10);
            /**
             * Since log computation is inexact, there may be an off-by-one error
             * in the computed magnitude. 
             * Following tests that magnitude is correct, and adjusts it if not
             */
            var xApprox = Math.Pow(10, xMag);
            if (xApprox * 10 <= xAbs)
                xMag += 1;

            return xMag;
        }


        /*------------------------------------------------------------
         *   Input
         *------------------------------------------------------------
         */

        /// <summary>
        /// Converts a string representation of a real number into a DoubleDouble value.
        /// The format accepted is similar to the standard Java real number syntax.  
        /// It is defined by the following regular expression:
        /// <pre>
        /// [<tt>+</tt>|<tt>-</tt>] {<i>digit</i>} [ <tt>.</tt> {<i>digit</i>} ] [ ( <tt>e</tt> | <tt>E</tt> ) [<tt>+</tt>|<tt>-</tt>] {<i>digit</i>}+
        /// </pre>
        ///  </summary>
        /// <param name="str">The string to parse</param>
        /// <returns>The value of the parsed number</returns>
        /// <exception cref="FormatException">Thrown if <tt>str</tt> is not a valid representation of a number</exception>
        public static DeterminantDouble Parse(String str)
        {
            int i = 0;
            int strlen = str.Length;

            // skip leading whitespace
            while (Char.IsWhiteSpace(str[i]))
                i++;

            // check for sign
            bool isNegative = false;
            if (i < strlen)
            {
                char signCh = str[i];
                if (signCh == '-' || signCh == '+')
                {
                    i++;
                    if (signCh == '-') isNegative = true;
                }
            }

            // scan all digits and accumulate into an integral value
            // Keep track of the location of the decimal point (if any) to allow scaling later
            DeterminantDouble val = new DeterminantDouble();

            int numDigits = 0;
            int numBeforeDec = 0;
            int exp = 0;
            while (true)
            {
                if (i >= strlen)
                    break;
                char ch = str[i];
                i++;
                if (Char.IsDigit(ch))
                {
                    double d = ch - '0';
                    val *= Ten;
                    // MD: need to optimize this
                    val += d;
                    numDigits++;
                    continue;
                }
                if (ch == '.')
                {
                    numBeforeDec = numDigits;
                    continue;
                }
                if (ch == 'e' || ch == 'E')
                {
                    String expStr = str.Substring(i);
                    // this should catch any format problems with the exponent
                    try
                    {
                        exp = int.Parse(expStr);
                    }
                    catch (FormatException ex)
                    {
                        throw new FormatException("Invalid exponent " + expStr + " in string " + str, ex);
                    }
                    break;
                }
                throw new FormatException("Unexpected character '" + ch
                                          + "' at position " + i
                                          + " in string " + str);
            }
            DeterminantDouble val2 = val;

            // scale the number correctly
            int numDecPlaces = numDigits - numBeforeDec - exp;
            if (numDecPlaces == 0)
            {
                val2 = val;
            }
            else if (numDecPlaces > 0)
            {
                var scale = Ten.Pow(numDecPlaces);
                val2 = val.Divide(scale);
            }
            else if (numDecPlaces < 0)
            {
                DeterminantDouble scale = Ten.Pow(-numDecPlaces);
                val2 = val * scale;
            }
            // apply leading sign, if any
            if (isNegative)
            {
                return val2.Negate();
            }
            return val2;

        }

        public static DeterminantDouble Copy(DeterminantDouble value)
        {
            return new DeterminantDouble(value);
        }

        public Object Clone()
        {
            return new DeterminantDouble(Hi, Lo);
        }

        public override bool Equals(object obj)
        {
            if (obj.IsNull())
            {
                return false;
            }

            if (!(obj is DeterminantDouble))
            {
                return false;
            }

            return Equals((DeterminantDouble)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (Hi.GetHashCode() * 397) ^ Lo.GetHashCode();
            }
        }
    }
}
