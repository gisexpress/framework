//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Linq;
using System.Xml;

namespace System
{
    public static class DoubleExtensions
    {
        public static int Abs(this int value)
        {
            return Math.Abs(value);
        }

        public static float Abs(this float value)
        {
            return Math.Abs(value);
        }

        public static double Abs(this double value)
        {
            return Math.Abs(value);
        }

        public static double Sign(this double value)
        {
            return value < 0.0 ? -1.0 : 1.0;
        }

        public static double Pow(this double value)
        {
            return value * value;
        }

        public static double Pow(this double value, int power)
        {
            switch (power)
            {
                case 2: return Pow(value);
                case 3: return Pow(value) * value;
                case 4: return Pow(value) * Pow(value);
                case 6: return Pow(value) * Pow(value) * Pow(value);
                case 8: return Pow(value) * Pow(value) * Pow(value) * Pow(value);
            }

            throw new NotImplementedException();
        }

        public static double Pow(this double value, double power)
        {
            return Math.Pow(value, power);
        }

        public static int Sqrt(this int value)
        {
            return (int)Math.Sqrt(value);
        }

        public static float Sqrt(this float value)
        {
            return (float)Math.Sqrt(value);
        }

        public static double Sqrt(this double value)
        {
            return Math.Sqrt(value);
        }

        public static double Round(this double value, int decimals)
        {
            return Math.Round(value, decimals);
        }

        public static double ReducePrecision(this double value)
        {
            return (double)new decimal(value);
        }

        public static double[] ReducePrecision(this double[] values)
        {
            return values.Select(n => ReducePrecision(n)).ToArray();
        }

        public static bool IsValid(this double value)
        {
            return !double.IsNaN(value) && !double.IsInfinity(value);
        }

        public static bool IsOne(this double value)
        {
            return (value - 1.0).IsZero();
        }

        public static bool IsZero(this double value)
        {
            return !(1.0 / value).IsValid();
        }

        public static bool IsBetween(this double value, double lower, double upper)
        {
            return value >= lower && value <= upper;
        }

        public static bool IsEquivalent(this double value, double other)
        {
            return value.ReducePrecision() == other.ReducePrecision();
        }

        public static double ReverseAngle(this double value)
        {
            return (AppConstants.TwoPI - value) % AppConstants.TwoPI;
        }

        public static double DegreeToRadian(this double degree)
        {
            return degree * AppConstants.Deg2Rad;
        }

        public static double RadianToDegree(this double degree)
        {
            return (degree * AppConstants.Rad2Deg);
        }

        public static string ToText(this double value)
        {
            return XmlConvert.ToString(value);
        }
    }
}
