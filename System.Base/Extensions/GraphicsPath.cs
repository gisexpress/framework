//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;

namespace System
{
    public static class GraphicsPathExtensions
    {
        public static RectangleF AlignPath(this GraphicsPath path, DrawTextEventArgs e)
        {
            return AlignPath(path, e, 1F);
        }

        public static RectangleF AlignPath(this GraphicsPath path, DrawTextEventArgs e, float penWidth)
        {
            float offsetX = 0F;
            float offsetY = 0F;

            using (var pen = new Pen(Color.Black))
            {
                if (!OSEnvironment.IsWindows)
                {
                    pen.Width = penWidth;
                }

                using (var matrix = new Matrix())
                {
                    RectangleF bounds = path.GetBounds(matrix, pen);

                    switch (e.Alignment)
                    {
                        case ContentAlignment.TopLeft:
                            offsetX = e.Origin.X - (bounds.Left + bounds.Width);
                            offsetY = e.Origin.Y - (bounds.Top + bounds.Height);
                            break;
                        case ContentAlignment.TopRight:
                            offsetX = e.Origin.X - bounds.Left;
                            offsetY = e.Origin.Y - (bounds.Top + bounds.Height);
                            break;
                        case ContentAlignment.TopCenter:
                            offsetX = e.Origin.X - (bounds.Left + bounds.Width / 2);
                            offsetY = e.Origin.Y - (bounds.Top + bounds.Height);
                            break;
                        case ContentAlignment.MiddleLeft:
                            offsetX = e.Origin.X - (bounds.Left + bounds.Width);
                            offsetY = e.Origin.Y - (bounds.Top + bounds.Height / 2);
                            break;
                        case ContentAlignment.MiddleRight:
                            offsetX = e.Origin.X - bounds.Left;
                            offsetY = e.Origin.Y - (bounds.Top + bounds.Height / 2);
                            break;
                        case ContentAlignment.MiddleCenter:
                            offsetX = e.Origin.X - (bounds.Left + bounds.Width / 2);
                            offsetY = e.Origin.Y - (bounds.Top + bounds.Height / 2);
                            break;
                        case ContentAlignment.BottomLeft:
                            offsetX = e.Origin.X - (bounds.Left + bounds.Width);
                            offsetY = e.Origin.Y - bounds.Top;
                            break;
                        case ContentAlignment.BottomRight:
                            offsetX = e.Origin.X - bounds.Left;
                            offsetY = e.Origin.Y - bounds.Top;
                            break;
                        case ContentAlignment.BottomCenter:
                            offsetX = e.Origin.X - (bounds.Left + bounds.Width / 2);
                            offsetY = e.Origin.Y - bounds.Top;
                            break;
                    }

                    matrix.Translate(offsetX * e.ScaleX, offsetY * e.ScaleY);
                    matrix.RotateAt(e.Angle, e.Origin);
                    matrix.ScaleAt(e.ScaleX, e.ScaleY, e.Origin.X, e.Origin.Y);

                    path.Transform(matrix);

                    return path.GetBounds();
                }
            }
        }

        public static void AddRectangle(this GraphicsPath path, Rectangle rect)
        {
            AddRectangle(path, rect.X, rect.Y, rect.Width, rect.Height, 0, Border3DSide.All);
        }

        public static void AddRectangle(this GraphicsPath path, Rectangle rect, int radius)
        {
            AddRectangle(path, rect.X, rect.Y, rect.Width, rect.Height, radius, Border3DSide.All);
        }

        public static void AddRectangle(this GraphicsPath path, Rectangle rect, Border3DSide sides)
        {
            AddRectangle(path, rect.X, rect.Y, rect.Width, rect.Height, 0, sides);
        }

        public static void AddRectangle(this GraphicsPath path, Rectangle rect, int radius, Border3DSide sides)
        {
            AddRectangle(path, rect.X, rect.Y, rect.Width, rect.Height, radius, sides);
        }

        public static void AddRectangle(this GraphicsPath path, int x, int y, int width, int height)
        {
            path.AddRectangle(new Rectangle(x, y, width, height));
        }

        public static void AddRectangle(this GraphicsPath path, float x, float y, float width, float height)
        {
            path.AddRectangle(new RectangleF(x, y, width, height));
        }

        public static void AddRectangle(this GraphicsPath path, int x, int y, int width, int height, int radius)
        {
            AddRectangle(path, x, y, width, height, radius, Border3DSide.All);
        }

        public static void AddRectangle(this GraphicsPath path, int x, int y, int width, int height, Border3DSide sides)
        {
            AddRectangle(path, x, y, width, height, 0, sides);
        }

        public static void AddRectangle(this GraphicsPath path, int x, int y, int width, int height, int radius, Border3DSide sides)
        {
            bool all = sides == Border3DSide.All;
            bool top = all || (Border3DSide.Top & sides) == Border3DSide.Top;
            bool left = all || (Border3DSide.Left & sides) == Border3DSide.Left;
            bool right = all || (Border3DSide.Right & sides) == Border3DSide.Right;
            bool bottom = all || (Border3DSide.Bottom & sides) == Border3DSide.Bottom;

            int xw = x + width;
            int yh = y + height;
            int xwr = xw - radius;
            int yhr = yh - radius;
            int xr = x + radius;
            int yr = y + radius;
            int r2 = radius * 2;
            int xwr2 = xw - r2;
            int yhr2 = yh - r2;

            if (top || left)
            {
                if (radius > 0)
                {
                    path.AddArc(x, y, r2, r2, 180, 90);
                }

                if (top)
                {
                    path.AddLine(xr, y, xwr, y);
                }
            }

            if (top || right)
            {
                if (radius > 0)
                {
                    path.AddArc(xwr2, y, r2, r2, 270, 90);
                }

                if (right)
                {
                    path.AddLine(xw, yr, xw, yhr);
                }
            }

            if (bottom || right)
            {
                if (radius > 0)
                {
                    path.AddArc(xwr2, yhr2, r2, r2, 0, 90);
                }

                if (bottom)
                {
                    path.AddLine(xwr, yh, xr, yh);
                }
            }

            if (bottom || left)
            {
                if (radius > 0)
                {
                    path.AddArc(x, yhr2, r2, r2, 90, 90);
                }

                if (left)
                {
                    path.AddLine(x, yhr, x, yr);
                }
            }
        }

        public static void AddCancelFigure(this GraphicsPath path, float x, float y, float width, float height)
        {
            using (var matrix = new Matrix())
            {
                float r = height / 2 - 6;
                PointF center = new PointF(x + width / 2, y + height / 2);

                matrix.RotateAt(135f, center);

                path.AddEllipse(center.X - r, center.Y - r, r * 2, r * 2);
                path.AddLine(center.X - r, center.Y, center.X + r, center.Y);
                path.Transform(matrix);
            }
        }
    }
}
