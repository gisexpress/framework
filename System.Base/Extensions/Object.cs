//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.ComponentModel;
using System.Data.Common;
using System.Drawing;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Xml;

namespace System
{
    public static class ObjectExtensions
    {
        static XmlWriterSettings FragmentSettings = new XmlWriterSettings { ConformanceLevel = ConformanceLevel.Fragment };

        //public static bool IsEmpty(this Guid value)
        //{
        //    return value == Guid.Empty;
        //}

        //public static string ToStringN(this Guid value)
        //{
        //    return value.ToString("N");
        //}

        //public static T ConvertTo<T>(this object value)
        //{
        //    return ConvertTo(value, default(T), default(IFormatProvider));
        //}

        //public static T ConvertTo<T>(this object value, IFormatProvider provider)
        //{
        //    return ConvertTo<T>(value, default(T), provider);
        //}

        //public static T ConvertTo<T>(this object value, T defaultValue)
        //{
        //    return ConvertTo<T>(value, defaultValue, default(IFormatProvider));
        //}

        //public static T ConvertTo<T>(this object value, T defaultValue, IFormatProvider provider)
        //{
        //    return (T)(ConvertTo(value, typeof(T), provider) ?? defaultValue);
        //}

        //public static object ConvertTo(this object value, Type conversionType)
        //{
        //    return ConvertTo(value, conversionType, default(IFormatProvider));
        //}

        //public static object ConvertTo(this object value, Type conversionType, IFormatProvider provider)
        //{
        //    if (value.HasValue())
        //    {
        //        if (conversionType.IsInstanceOfType(value))
        //        {
        //            return value;
        //        }

        //        if (conversionType.IsEnum)
        //        {
        //            var name = value as string;

        //            if (string.IsNullOrEmpty(name))
        //            {
        //                return Enum.ToObject(conversionType, value);
        //            }
        //            else
        //            {
        //                return Enum.Parse(conversionType, name, true);
        //            }
        //        }

        //        if (value is IConvertible && Types.IConvertible.IsAssignableFrom(conversionType))
        //        {
        //            return Convert.ChangeType(value, conversionType, provider ?? CultureInfo.InvariantCulture);
        //        }

        //        TypeConverter converter = TypeDescriptor.GetConverter(conversionType, true);

        //        if (converter.HasValue() && converter.CanConvertFrom(value.GetType()))
        //        {
        //            return converter.ConvertFrom(value);
        //        }
        //    }

        //    return default(object);
        //}

        public static bool IsNull(this object value)
        {
            return value == null;
        }

        public static bool HasValue(this object value)
        {
            if (value == null)
            {
                return false;
            }

            return true;
        }

        public static bool IsNullOrDBNull(this object value)
        {
            return value == null || value == Convert.DBNull;
        }

        public static bool IsNullOrEmpty(this object value)
        {
            if (IsNullOrDBNull(value))
            {
                return true;
            }

            if (value is string && string.IsNullOrEmpty(value as string))
            {
                return true;
            }

            return false;
        }

        public static byte[] GetBytes(object value)
        {
            return GetBytes(value, Marshal.SizeOf(value));
        }

        public static byte[] GetBytes(object value, int size)
        {
            var ptr = IntPtr.Zero;
            var bytes = new byte[size];

            try
            {
                ptr = Marshal.AllocHGlobal(size);
                Marshal.StructureToPtr(value, ptr, true);
                Marshal.Copy(ptr, bytes, 0, size);
                return bytes;
            }
            finally
            {
                Marshal.FreeHGlobal(ptr);
            }
        }

        //public static T ParseInvariantString<T>(this string value)
        //{
        //    return (T)ParseInvariantString(value, typeof(T));
        //}

        //public static object ParseInvariantString(this string value, Type type)
        //{
        //    return ParseInvariantString(value, type, Type.GetTypeCode(type));
        //}

        //public static object ParseInvariantString(this string value, Type valueType, TypeCode valueTypeCode)
        //{
        //    if (!string.IsNullOrEmpty(value) && valueType.HasValue())
        //    {
        //        if (valueType.IsEnum)
        //        {
        //            return Enum.Parse(valueType, value);
        //        }

        //        switch (valueTypeCode)
        //        {
        //            case TypeCode.Byte:
        //                return XmlConvert.ToByte(value);

        //            case TypeCode.SByte:
        //                return XmlConvert.ToSByte(value);

        //            case TypeCode.Boolean:
        //                return XmlConvert.ToBoolean(value);

        //            case TypeCode.Char:
        //                return XmlConvert.ToChar(value);

        //            case TypeCode.DateTime:
        //                return XmlConvert.ToDateTime(value, XmlDateTimeSerializationMode.Local);

        //            case TypeCode.Decimal:
        //                return XmlConvert.ToDecimal(value);

        //            case TypeCode.Double:
        //                return XmlConvert.ToDouble(value);

        //            case TypeCode.Int16:
        //                return XmlConvert.ToInt16(value);

        //            case TypeCode.Int32:
        //                return XmlConvert.ToInt32(value);

        //            case TypeCode.Int64:
        //                return XmlConvert.ToInt64(value);

        //            case TypeCode.Single:
        //                return XmlConvert.ToSingle(value);

        //            case TypeCode.UInt16:
        //                return XmlConvert.ToUInt16(value);

        //            case TypeCode.UInt32:
        //                return XmlConvert.ToUInt32(value);

        //            case TypeCode.UInt64:
        //                return XmlConvert.ToUInt64(value);

        //            case TypeCode.String:
        //                return value;
        //        }

        //        if (Types.Color.Equals(valueType))
        //        {
        //            int a, r, g, b;

        //            int.TryParse(value.Substring(0, 2), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out a);
        //            int.TryParse(value.Substring(2, 2), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out b);
        //            int.TryParse(value.Substring(4, 2), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out g);
        //            int.TryParse(value.Substring(6, 2), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out r);

        //            return Color.FromArgb(a, r, g, b);
        //        }
        //        else if (Types.TimeSpan.Equals(valueType))
        //        {
        //            return TimeSpan.ParseExact(value, @"hh\:mm\:ss", CultureInfo.InvariantCulture);
        //        }
        //        else if (valueType.IsArray && Types.Bytes.Equals(valueType))
        //        {
        //            return value.HexStringToByteArray();
        //        }
        //        else if (Types.Bitmap.Equals(valueType))
        //        {
        //            return (ParseInvariantString(value, Types.Bytes, TypeCode.Object) as byte[]).ToBitmap();
        //        }
        //    }

        //    return DeserializeObject(value, valueType);
        //}

        //public static string ToInvariantString(this object value)
        //{
        //    if (value.HasValue())
        //    {
        //        return ToInvariantString(value, value.GetType());
        //    }

        //    return default(string);
        //}

        //public static string ToInvariantString(this object value, Type type)
        //{
        //    return ToInvariantString(value, type, Type.GetTypeCode(type));
        //}

        //public static string ToInvariantString(this object value, Type valueType, TypeCode valueTypeCode)
        //{
        //    if (valueType.IsEnum)
        //    {
        //        return Enum.GetName(valueType, value);
        //    }

        //    switch (valueTypeCode)
        //    {
        //        case TypeCode.Byte:
        //            return XmlConvert.ToString((byte)value);

        //        case TypeCode.SByte:
        //            return XmlConvert.ToString((sbyte)value);

        //        case TypeCode.Boolean:
        //            return XmlConvert.ToString((bool)value);

        //        case TypeCode.Char:
        //            return XmlConvert.ToString((char)value);

        //        case TypeCode.DateTime:
        //            return XmlConvert.ToString((DateTime)value, XmlDateTimeSerializationMode.Local);

        //        case TypeCode.Decimal:
        //            return XmlConvert.ToString((decimal)value);

        //        case TypeCode.Double:
        //            return XmlConvert.ToString((double)value);

        //        case TypeCode.Int16:
        //            return XmlConvert.ToString((short)value);

        //        case TypeCode.Int32:
        //            return XmlConvert.ToString((int)value);

        //        case TypeCode.Int64:
        //            return XmlConvert.ToString((long)value);

        //        case TypeCode.Single:
        //            return XmlConvert.ToString((float)value);

        //        case TypeCode.UInt16:
        //            return XmlConvert.ToString((ushort)value);

        //        case TypeCode.UInt32:
        //            return XmlConvert.ToString((uint)value);

        //        case TypeCode.UInt64:
        //            return XmlConvert.ToString((ulong)value);

        //        case TypeCode.String:
        //            return (string)value;
        //    }

        //    if (valueType.IsArray)
        //    {
        //        if (Types.Bytes.Equals(valueType))
        //        {
        //            return (value as byte[]).ToHexString();
        //        }
        //    }

        //    if (Types.TimeSpan.Equals(valueType))
        //    {
        //        return ((TimeSpan)value).ToString(@"hh\:mm\:ss", CultureInfo.InvariantCulture);
        //    }

        //    if (Types.Bitmap.Equals(valueType))
        //    {
        //        return (value as Bitmap).GetBytes().ToInvariantString();
        //    }

        //    return SerializeObject(value, valueType);
        //}

        //static string SerializeObject(object component, Type componentType)
        //{
        //    var builder = new DbConnectionStringBuilder();
        //    var properties = componentType.GetPropertyDescriptors();

        //    foreach (PropertyDescriptor property in properties)
        //    {
        //        if (property.IsReadOnly)
        //        {
        //            continue;
        //        }

        //        builder.Add(property.Name, ToInvariantString(property.GetValue(component), property.PropertyType));
        //    }

        //    return builder.ConnectionString;
        //}

        //static object DeserializeObject(string value, Type componentType)
        //{
        //    if (string.IsNullOrEmpty(value))
        //    {
        //        return null;
        //    }

        //    var component = Activator.CreateInstance(componentType);
        //    var properties = componentType.GetPropertyDescriptors();
        //    var builder = new DbConnectionStringBuilder { ConnectionString = value };

        //    foreach (string keyword in builder.Keys)
        //    {
        //        string propertyValue;
        //        PropertyDescriptor property = properties.Find(keyword, true);

        //        if (property.HasValue() && !property.IsReadOnly)
        //        {
        //            propertyValue = builder[keyword] as string;

        //            if (propertyValue.HasValue())
        //            {
        //                property.SetValue(component, ConvertTo(propertyValue, property.PropertyType));
        //            }
        //        }
        //    }

        //    return component;
        //}

        public static IDisposable Begin(this ISupportInitialize component)
        {
            return Begin(component, true);
        }

        public static IDisposable Begin(this ISupportInitialize component, bool perform)
        {
            if (component == null)
            {
                return default(IDisposable);
            }

            return new InitializeSession(component).Start(perform);
        }

        class InitializeSession : IDisposable
        {
            public InitializeSession(ISupportInitialize component)
            {
                Component = component;
            }

            protected ISupportInitialize Component;

            public IDisposable Start(bool perform)
            {
                if (perform)
                {
                    Component.BeginInit();
                }
                else
                {
                    Component = null;
                }

                return this;
            }

            public void Dispose()
            {
                if (Component.HasValue())
                {
                    Component.EndInit();
                    Component = null;
                }

                GC.SuppressFinalize(this);
            }
        }

        public static T CloneSafely<T>(this T component)
        {
            var c = component as ICloneable;

            if (c.HasValue())
            {
                return (T)c.Clone();
            }

            return component;
        }

        public static bool DisposeSafely(this object component)
        {
            return DisposeSafely((component as IDisposable));
        }

        public static bool DisposeSafely(this IDisposable component)
        {
            if (component.HasValue())
            {
                component.Dispose();
                return true;
            }

            return false;
        }
    }
}
