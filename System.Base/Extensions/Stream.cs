//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;

namespace System
{
    public static class StreamExtensions
    {
        public static Stream Open(this Stream s)
        {
            if (s.CanSeek)
            {
                int byte1 = s.ReadByte();
                int byte2 = s.ReadByte();
                int byte3 = s.ReadByte();
                int byte4 = s.ReadByte();

                s.Reset();

                if (byte1 == 0x1F && byte2 == 0x8B)
                {
                    return new GZipNativeStream(s, CompressionMode.Decompress);
                }
                else if (byte1 == 0xED && byte2 == 0xBD)
                {
                    return new DeflateNativeStream(s, CompressionMode.Decompress);
                }
                else if (byte1 == 0x50 && byte2 == 0x4B && byte3 == 0x3 && byte4 == 0x4)
                {
                    ZipEntry zipFile = Zip.Open(s).Entries.FirstOrDefault(e => e.IsFile);

                    if (zipFile.HasValue())
                    {
                        return zipFile.GetStream();
                    }
                }
            }

            return s;
        }

        public static bool CanRead(this Stream s)
        {
            return s.Position < s.Length;
        }

        public static void Reset(this Stream s)
        {
            if (s.CanSeek)
            {
                s.Position = 0L;
            }
        }

        public static void Clear(this Stream s)
        {
            s.SetLength(0L);
        }

        public static void CopyTo(this Stream source, Stream target)
        {
            int count;
            var buffer = new byte[0x10000];

            while ((count = source.Read(buffer, 0, buffer.Length)) > 0)
            {
                target.Write(buffer, 0, count);
            }
        }

        public static bool ReadBoolean(this Stream input)
        {
            return input.ReadByte() > 0;
        }

        public static short ReadInt16(this Stream input)
        {
            return BitConverter.ToInt16(ReadBytes(input, 2), 0);
        }

        public static int ReadInt32(this Stream input)
        {
            return BitConverter.ToInt32(ReadBytes(input, 4), 0);
        }

        [CLSCompliant(false)]
        public static uint ReadUInt32(this Stream input)
        {
            return BitConverter.ToUInt32(ReadBytes(input, 4), 0);
        }

        public static float ReadSingle(this Stream input)
        {
            return BitConverter.ToSingle(ReadBytes(input, 4), 0);
        }

        public static IEnumerable<float> ReadSingle(this Stream input, int count)
        {
            byte[] buffer = ReadBytes(input, 4 * count);

            for (int i = 0; i < 4; i++)
            {
                yield return BitConverter.ToSingle(buffer, i * 4);
            }
        }

        public static long ReadInt64(this Stream input)
        {
            return BitConverter.ToInt64(ReadBytes(input, 8), 0);
        }

        [CLSCompliant(false)]
        public static ulong ReadUInt64(this Stream input)
        {
            return BitConverter.ToUInt64(ReadBytes(input, 8), 0);
        }

        public static double ReadDouble(this Stream input)
        {
            return BitConverter.ToDouble(ReadBytes(input, 8), 0);
        }

        public static decimal ReadDecimal(this Stream input)
        {
            byte[] buffer = ReadBytes(input, 16);

            return new decimal(new int[] { BitConverter.ToInt32(buffer, 0), BitConverter.ToInt32(buffer, 4), BitConverter.ToInt32(buffer, 8), BitConverter.ToInt32(buffer, 12) });
        }

        public static void Write(this Stream output, byte value)
        {
            output.WriteByte(value);
        }

        public static void Write(this Stream output, bool value)
        {
            output.WriteByte(Convert.ToByte(value));
        }

        public static void Write(this Stream output, short value)
        {
            output.Write(BitConverter.GetBytes(value), 0, 2);
        }

        public static void Write(this Stream output, int value)
        {
            output.Write(BitConverter.GetBytes(value), 0, 4);
        }

        [CLSCompliant(false)]
        public static void Write(this Stream output, uint value)
        {
            output.Write(BitConverter.GetBytes(value), 0, 4);
        }

        public static int Write(this Stream output, IEnumerable<int> values)
        {
            byte[] buffer = values.SelectMany(i => BitConverter.GetBytes(i)).ToArray();
            output.Write(buffer, 0, buffer.Length);
            return buffer.Length;
        }

        public static void Write(this Stream output, long value)
        {
            output.Write(BitConverter.GetBytes(value), 0, 8);
        }

        public static void Write(this Stream output, float value)
        {
            output.Write(BitConverter.GetBytes(value), 0, 4);
        }

        public static void Write(this Stream output, float[] values)
        {
            output.Write(values.SelectMany(e => BitConverter.GetBytes(e)).ToArray(), 0, 4 * values.Length);
        }

        public static void Write(this Stream output, double value)
        {
            output.Write(BitConverter.GetBytes(value), 0, 8);
        }

        public static void Write(this Stream output, decimal value)
        {
            Write(output, decimal.GetBits(value));
        }

        public static void Write(this Stream output, byte[] array)
        {
            if (array == null || array.Length == 0)
            {
                return;
            }

            output.Write(array, 0, array.Length);
        }

        public static long GetChecksum(this Stream input)
        {
            return ReadBytes(input).GetChecksum();
        }

        public static byte[] ReadBytes(this Stream input)
        {
            if (input.CanSeek)
            {
                long position = input.Position;
                byte[] buffer = new byte[input.Length - position];

                input.Read(buffer, 0, buffer.Length);
                input.Position = position;

                return buffer;
            }

            using (var target = new MemoryStream())
            {
                input.CopyTo(target);
                target.Close();
                return target.ToArray();
            }
        }

        public static byte[] ReadBytes(this Stream input, long count)
        {
            var buffer = new byte[count];

            if (input.Read(buffer, 0, buffer.Length) == count)
            {
                return buffer;
            }

            throw new EndOfStreamException();
        }

        public static void WriteTo(this Stream source, Stream destination, int length)
        {
            var buffer = new byte[length];
            long position = source.Position;
            source.Position = 0;
            source.Read(buffer, 0, length);
            source.Position = position;
            destination.Write(buffer, 0, length);
        }

        public static byte[] Compress(this Stream input)
        {
            using (var output = new MemoryStream())
            {
                using (var deflate = new DeflateStream(output, CompressionMode.Compress))
                {
                    deflate.Write(input.ReadBytes());
                }

                return output.ToArray();
            }
        }

        public static byte[] Decompress(this Stream input)
        {
            return Decompress(input, (int)input.Length);
        }

        public static byte[] Decompress(this Stream input, int count)
        {
            using (var output = new MemoryStream(input.ReadBytes(count)))
            {
                using (var deflate = new DeflateStream(output, CompressionMode.Decompress))
                {
                    return deflate.ReadBytes();
                }
            }
        }

        public static Stream ToDeflateStream(this Stream s, bool compress)
        {
            return new DeflateNativeStream(s, compress ? CompressionMode.Compress : CompressionMode.Decompress);
        }

        public static Stream ToGZipStream(this Stream s, bool compress)
        {
            return ToGZipStream(s, compress, false);
        }

        public static Stream ToGZipStream(this Stream s, bool compress, bool leaveOpen)
        {
            return new GZipNativeStream(s, compress ? CompressionMode.Compress : CompressionMode.Decompress, leaveOpen);
        }
    }
}