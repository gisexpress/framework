//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace System
{
    public static class StringExtensions
    {
        const char AnyChar = '_';
        const string WildChar = "*";
        const string WholeWordChar = @"\b";
        const string WholeWordMark = @"""";

        const char DotSeparator = '.';
        const string HexPattern = @"\A\b[0-9a-fA-F]+\b\Z";
        const string Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        static readonly Random Random = new Random();

        public static string ToTitleCase(this string s)
        {
            return ToTitleCase(s, CultureInfo.InvariantCulture);
        }

        public static string ToTitleCase(this string s, CultureInfo culture)
        {
            return culture.TextInfo.ToTitleCase(culture.TextInfo.ToLower(s));
        }

        public static string Format(this string format, params object[] args)
        {
            return Format(Localization.Language, args);
        }

        public static string Format(this string format, IFormatProvider provider, params object[] args)
        {
            return string.Format(provider, format, args);
        }

        public static string FormatInvariant(this string format, params object[] args)
        {
            return string.Format(CultureInfo.InvariantCulture, format, args);
        }

        public static bool EqualsIgnoreCase(this string value, string other)
        {
            return string.Equals(value, other, StringComparison.InvariantCultureIgnoreCase);
        }

        public static bool ContainsIgnoreCase(this string value, string other)
        {
            return value.IndexOf(other, StringComparison.InvariantCultureIgnoreCase) >= 0;
        }

        public static bool ContainsIgnoreCaseAny(this string value, params string[] keywords)
        {
            return keywords.Any(e => value.ContainsIgnoreCase(e));
        }

        public static bool ContainsIgnoreCaseAll(this string value, IEnumerable<string> keywords)
        {
            return keywords.All(e => value.ContainsIgnoreCase(e));
        }

        public static string RemoveEndsWith(this string value, params string[] keywords)
        {
            foreach (string key in keywords)
            {
                if (value.EndsWithIgnoreCase(key))
                {
                    value = value.Remove(value.Length - key.Length);
                }
            }

            return value;
        }

        public static bool RemoveEndsWith(this string value, out string match, out string newValue, params string[] keywords)
        {
            newValue = value;

            foreach (string key in keywords)
            {
                if (newValue.EndsWithIgnoreCase(key))
                {
                    match = key;
                    newValue = newValue.Remove(value.Length - key.Length);
                    return true;
                }
            }

            match = default(string);
            return false;
        }

        public static bool StartsWithIgnoreCase(this string value, string other)
        {
            if (string.IsNullOrEmpty(value))
            {
                return false;
            }

            return value.StartsWith(other, StringComparison.InvariantCultureIgnoreCase);
        }

        public static bool EndsWithIgnoreCase(this string value, string other)
        {
            return value.EndsWith(other, StringComparison.InvariantCultureIgnoreCase);
        }

        public static IList<string> SplitList(this string value)
        {
            return value.Split(DotSeparator);
        }

        public static IList<string> SplitList(this string value, params char[] seperator)
        {
            return value.Split(seperator);
        }

        public static IList<string> SplitWithoutEmptyEntries(this string value)
        {
            return SplitWithoutEmptyEntries(value, DotSeparator);
        }

        public static IList<string> SplitWithoutEmptyEntries(this string value, params char[] seperator)
        {
            return value.Split(seperator, StringSplitOptions.RemoveEmptyEntries);
        }

        public static string RemoveNewLines(this string value)
        {
            return RemoveNewLines(value, string.Empty);
        }

        public static string RemoveNewLines(this string value, string replacement)
        {
            if (string.IsNullOrEmpty(value))
            {
                return value;
            }

            return Regex.Replace(value, @"\t|\n|\r", replacement);
        }

        public static bool ToBoolean(this string value)
        {
            if (!string.IsNullOrEmpty(value))
            {
                return value.EqualsIgnoreCase("1") || value.EqualsIgnoreCase("True") || value.EqualsIgnoreCase("Yes") || value.EqualsIgnoreCase(Localization.Localize("Yes"));
            }

            return false;
        }

        public static int ToInt32(this string input)
        {
            int value;

            if (!string.IsNullOrEmpty(input) && int.TryParse(input, out value))
            {
                return value;
            }

            return 0;
        }

        public static Guid ToGuid(this string input)
        {
            Guid value;

            if (!string.IsNullOrEmpty(input) && Guid.TryParse(input, out value))
            {
                return value;
            }

            return Guid.Empty;
        }

        public static bool IsHex(this string value)
        {
            return !string.IsNullOrEmpty(value) && Regex.IsMatch(value, HexPattern);
        }

        public static byte[] HexStringToByteArray(this string value)
        {
            if (IsHex(value))
            {
                return Enumerable.Range(0, value.Length).Where(x => x % 2 == 0).Select(x => Convert.ToByte(value.Substring(x, 2), 16)).ToArray();
            }

            return null;
        }

        public static byte[] GetBytes(this string value)
        {
            return value.ToCharArray().SelectMany(BitConverter.GetBytes).ToArray();
        }

        public static Stream ToStream(this string value)
        {
            var stream = new MemoryStream();
            var writer = new StreamWriter(stream);

            writer.Write(value);
            writer.Flush();
            stream.Reset();

            return stream;
        }

        public static void Print(this Exception e)
        {
            if (e.HasValue())
            {
                if (DeveloperEnvironment.DebugMode)
                {
                    e.ToString().Print();
                }
                else
                {
                    (e.GetBaseException() ?? e).Message.Print();
                }
            }
        }

        public static void Print(this string message)
        {
            if (DeveloperEnvironment.DebugMode)
            {
                Console.WriteLine(message);
            }
        }

        public static bool Like(string input, string findWhat)
        {
            return Like(input, findWhat, RegexOptions.None);
        }

        public static bool iLike(string input, string findWhat)
        {
            return Like(input, findWhat, RegexOptions.IgnoreCase);
        }

        private static bool Like(string input, string findWhat, RegexOptions options)
        {
            if (!string.IsNullOrEmpty(input))
            {
                string pattern = findWhat.Replace(AnyChar, '.').Replace(WildChar, ".*");

                if (findWhat.StartsWith(WholeWordMark) && findWhat.EndsWith(WholeWordMark))
                {
                    pattern = string.Concat(WholeWordChar, pattern.Trim(WholeWordChar.ToCharArray()), WholeWordChar);
                }
                else
                {
                    pattern = string.Concat(@"\A", pattern, @"\z");
                }

                if (Regex.IsMatch(input, pattern, RegexOptions.Compiled | options))
                {
                    return true;
                }
            }

            return false;
        }

        public static bool LikeAll(string input, string findWhat)
        {
            return Like(input, findWhat, RegexOptions.None);
        }

        public static bool iLikeAll(string input, string findWhat)
        {
            return Like(input, findWhat, RegexOptions.IgnoreCase);
        }

        private static bool LikeAll(string input, string findWhat, RegexOptions options)
        {
            if (!string.IsNullOrEmpty(findWhat))
            {
                foreach (string word in findWhat.SplitWithoutEmptyEntries(' '))
                {
                    if (!Like(input, string.Concat('*', word, '*'), options))
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        public static string RandomString(int length)
        {
            return new string(Enumerable.Repeat(Chars, length).Select(s => s[Random.Next(s.Length)]).ToArray());
        }

        public static int GetSafeHashCode(this string value)
        {
            unchecked
            {
                int hash = Hash.Seed;

                foreach (char c in value)
                {
                    hash = hash * Hash.Step + c;
                }

                return hash;
            }
        }
    }
}