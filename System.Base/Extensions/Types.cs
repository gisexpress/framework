//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using System.Xml;
using System.Xml.Serialization;

public static class Types
{
    public static readonly object[] EmptyObjectArray = new object[] { };

    public static readonly Type[] TypeArrayEmpty = new Type[] { };
    public static readonly Type[] TypeArrayObject = new Type[] { typeof(object) };

    public static readonly Type Byte = typeof(byte);
    public static readonly Type SByte = typeof(sbyte);
    public static readonly Type Boolean = typeof(bool);
    public static readonly Type Char = typeof(char);
    public static readonly Type Int16 = typeof(short);
    public static readonly Type Int32 = typeof(int);
    public static readonly Type Int64 = typeof(long);
    public static readonly Type UInt16 = typeof(ushort);
    public static readonly Type UInt32 = typeof(uint);
    public static readonly Type UInt64 = typeof(ulong);
    public static readonly Type Single = typeof(float);
    public static readonly Type Double = typeof(double);
    public static readonly Type Decimal = typeof(decimal);
    public static readonly Type String = typeof(string);
    public static readonly Type Bytes = typeof(byte[]);
    public static readonly Type Guid = typeof(Guid);
    public static readonly Type DateTime = typeof(DateTime);
    public static readonly Type DateTimeOffset = typeof(DateTimeOffset);
    public static readonly Type TimeSpan = typeof(TimeSpan);
    public static readonly Type Color = typeof(Color);
    public static readonly Type Bitmap = typeof(Bitmap);
    public static readonly Type Disposable = typeof(IDisposable);
    public static readonly Type Object = typeof(object);

    public static readonly Type Exception = typeof(Exception);

    public static readonly Type EnumTypeCode = typeof(TypeCode);
    public static readonly Type EnumDateTimeKind = typeof(DateTimeKind);

    public static readonly Type Enumerable = typeof(Enumerable);
    public static readonly Type IEnumerable = typeof(IEnumerable);
    public static readonly Type IEnumerableT = typeof(IEnumerable<>);
    public static readonly Type IEnumerableDataRecord = typeof(IEnumerable<IDataRecord>);

    public static readonly Type FuncT = typeof(Func<,>);
    public static readonly Type FuncObj = typeof(Func<object>);
    public static readonly Type FuncObjObj = typeof(Func<object, object>);
    public static readonly Type GenericArgument = typeof(Action<>).GetGenericArguments().First();

    public static readonly Type IList = typeof(IList);
    public static readonly Type IListT = typeof(IList<>);
    public static readonly Type IDbConnection = typeof(IDbConnection);
    public static readonly Type IDbCommand = typeof(IDbCommand);
    public static readonly Type IDataRecord = typeof(IDataRecord);
    public static readonly Type IDataParameter = typeof(IDataParameter);
    public static readonly Type IDataParameterCollection = typeof(IDataParameterCollection);
    public static readonly Type IDictionary = typeof(IDictionary);

    public static readonly Type ComparerT = typeof(Comparer<>);
    public static readonly Type IComparerT = typeof(IComparer<>);
    public static readonly Type IConvertible = typeof(IConvertible);
    public static readonly Type IKeyedObject = typeof(IKeyedObject);
    public static readonly Type IXmlSerializable = typeof(IXmlSerializable);
    public static readonly Type XmlElementBase = typeof(XmlElementBase);

    public static readonly Type Form = typeof(Form);
    public static readonly Type Control = typeof(Control);
    public static readonly Type TypeEditor = typeof(Control);

    public static readonly Type CollectionExtensions = typeof(CollectionExtensions);

    public static readonly Type DefaultValueAttribute = typeof(DefaultValueAttribute);

    public static bool IsEquivalent(this Type value, Type other)
    {
        if (value.IsGenericType && other.IsGenericType)
        {
            return IsEquivalent(value.GetGenericArguments(), other.GetGenericArguments());
        }

        if (IsEquivalent(Type.GetTypeCode(value), Type.GetTypeCode(other)))
        {
            return true;
        }

        return value.FullName == other.FullName;
    }

    public static bool IsEquivalent(TypeCode value, TypeCode other)
    {
        return value == other && value != TypeCode.Object;
    }

    public static bool IsEquivalent(this IEnumerable<Type> value, IEnumerable<Type> other)
    {
        return IsEquivalent(value.ToList(), other.ToList());
    }

    public static bool IsEquivalent(this ICollection<Type> value, IList<Type> other)
    {
        if (value.Count == other.Count)
        {
            IEnumerator<Type> e0 = value.GetEnumerator();
            IEnumerator<Type> e1 = other.GetEnumerator();

            while (e0.MoveNext() && e1.MoveNext())
            {
                if (!IsEquivalent(e0.Current, e1.Current))
                {
                    return false;
                }
            }

            return true;
        }

        return false;
    }

    public static bool IsObject(this Type value)
    {
        return Type.GetTypeCode(value) == TypeCode.Object;
    }

    public static bool IsString(this Type value)
    {
        return Type.GetTypeCode(value) == TypeCode.String;
    }

    public static bool IsNumeric(this Type value)
    {
        switch (Type.GetTypeCode(value))
        {
            case TypeCode.Byte:
            case TypeCode.SByte:
            case TypeCode.Int16:
            case TypeCode.Int32:
            case TypeCode.Int64:
            case TypeCode.UInt16:
            case TypeCode.UInt32:
            case TypeCode.UInt64:
            case TypeCode.Single:
            case TypeCode.Double:
            case TypeCode.Decimal:
                return true;
        }

        return false;
    }

    public static object MinValue(this Type value)
    {
        switch (Type.GetTypeCode(value))
        {
            case TypeCode.Byte: return byte.MinValue;
            case TypeCode.SByte: return sbyte.MinValue;
            case TypeCode.Char: return char.MinValue;
            case TypeCode.Int16: return short.MinValue;
            case TypeCode.Int32: return int.MinValue;
            case TypeCode.Int64: return long.MinValue;
            case TypeCode.UInt16: return ushort.MinValue;
            case TypeCode.UInt32: return uint.MinValue;
            case TypeCode.UInt64: return ulong.MinValue;
            case TypeCode.Single: return float.MinValue;
            case TypeCode.Double: return double.MinValue;
            case TypeCode.Decimal: return decimal.MinValue;
            case TypeCode.DateTime: return System.DateTime.MinValue;
        }

        throw new NotSupportedException();
    }

    public static object MaxValue(this Type value)
    {
        switch (Type.GetTypeCode(value))
        {
            case TypeCode.Byte: return byte.MaxValue;
            case TypeCode.SByte: return sbyte.MaxValue;
            case TypeCode.Char: return char.MaxValue;
            case TypeCode.Int16: return short.MaxValue;
            case TypeCode.Int32: return int.MaxValue;
            case TypeCode.Int64: return long.MaxValue;
            case TypeCode.UInt16: return ushort.MaxValue;
            case TypeCode.UInt32: return uint.MaxValue;
            case TypeCode.UInt64: return ulong.MaxValue;
            case TypeCode.Single: return float.MaxValue;
            case TypeCode.Double: return double.MaxValue;
            case TypeCode.Decimal: return decimal.MaxValue;
            case TypeCode.DateTime: return System.DateTime.MaxValue;
        }

        throw new NotSupportedException();
    }

    public static object Default(this Type value)
    {
        if (value.IsValueType)
        {
            return Activator.CreateInstance(value);
        }
        else if (value.IsEquivalent(Types.String))
        {
            return string.Empty;
        }

        return default(object);
    }
}