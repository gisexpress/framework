//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.ComponentModel;
using System.CoordinateSystems;
using System.Runtime.InteropServices;
using System.Xml;

namespace System.Geometries
{
    [Guid("4E8D5CB0-ECFC-4AA8-A067-CC4DA7D77C09")]
    public interface IEnvelope : ISupportInitialize, IComparable<IEnvelope>, IEquatable<IEnvelope>, IIntersectable<IEnvelope>, IExpandable<IEnvelope>, IEnumerable<ICoordinate>, ICloneable
    {
        IGeometryFactory Factory
        {
            get;
        }

        bool IsEmpty();
        void SetNull();

        double GetArea();
        double GetWidth();
        double GetHeight();

        ICoordinate Min { get; }
        ICoordinate Max { get; }

        void Init(double[] values);
        void Init(ICoordinate min, ICoordinate max);
        void Init(double x1, double x2, double y1, double y2);
        void Init(double x1, double x2, double y1, double y2, double z1, double z2);

        double GetCenterX();
        double GetCenterY();
        ICoordinate GetCenter();

        double Distance(IEnvelope other);

        bool Contains(IEnvelope other);
        bool Contains(ICoordinate point);
        bool Contains(double x, double y);

        bool Intersects(ICoordinate other);
        bool Intersects(ICoordinate min, ICoordinate max);

        void Inflate(double x, double y);
        void ExpandToInclude(ICoordinate c);

        IEnvelope Zoom(double percent);
        IEnvelope Zoom(double percentX, double percentY);
        IEnvelope Union(IEnvelope e);
        IEnvelope Normalize(int width, int height);
        IEnvelope Transform(IMathTransform transform);

        IPolygon ToPolygon();
        IEnumerable<ILineSegment> GetSegments();

        void LoadXml(XmlNode node);
        void SaveXml(XmlNode node);

        new IEnvelope Clone();
    }
}
