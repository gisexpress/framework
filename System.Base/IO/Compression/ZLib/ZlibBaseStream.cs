//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

namespace System.IO.Compression
{
    internal class ZlibBaseStream : Stream
    {
        public ZlibBaseStream(Stream stream, CompressionMode compressionMode, CompressionLevel level, ZlibStreamFlavor flavor, bool leaveOpen)
            : base()
        {
            FlushMode = FlushType.None;
            StreamBase = stream;
            LeaveOpen = leaveOpen;
            CompressionMode = compressionMode;
            Flavor = flavor;
            Level = level;

            // workitem 7159
            if (flavor == ZlibStreamFlavor.GZip)
            {
                crc = new CRC32();
            }
        }

        protected internal ZlibCodec Codec = null;

        protected internal StreamMode Mode = StreamMode.Undefined;
        protected internal FlushType FlushMode;
        protected internal ZlibStreamFlavor Flavor;
        protected internal CompressionMode CompressionMode;
        protected internal CompressionLevel Level;
        protected internal bool LeaveOpen;
        protected internal byte[] WorkingBuffer;
        protected internal int BufferSize = ZlibConstants.WorkingBufferSizeDefault;
        protected internal byte[] Buffer1 = new byte[1];

        protected internal Stream StreamBase;
        protected internal CompressionStrategy Strategy = CompressionStrategy.Default;

        // workitem 7159
        CRC32 crc;
        protected internal string GzipFileName;
        protected internal string GzipComment;
        protected internal DateTime GzipMtime;
        protected internal int GzipHeaderByteCount;

        internal int Crc32
        {
            get
            {
                if (crc.IsNull())
                {
                    return 0;
                }

                return crc.Crc32Result;
            }
        }

        protected internal bool _wantCompress
        {
            get { return CompressionMode == CompressionMode.Compress; }
        }

        ZlibCodec z
        {
            get
            {
                if (Codec.IsNull())
                {
                    bool wantRfc1950Header = (this.Flavor == ZlibStreamFlavor.ZLib);
                    Codec = new ZlibCodec();
                    if (this.CompressionMode == CompressionMode.Decompress)
                    {
                        Codec.InitializeInflate(wantRfc1950Header);
                    }
                    else
                    {
                        Codec.Strategy = Strategy;
                        Codec.InitializeDeflate(this.Level, wantRfc1950Header);
                    }
                }
                return Codec;
            }
        }



        private byte[] workingBuffer
        {
            get
            {
                if (WorkingBuffer.IsNull())
                    WorkingBuffer = new byte[BufferSize];
                return WorkingBuffer;
            }
        }



        public override void Write(System.Byte[] buffer, int offset, int count)
        {
            // workitem 7159
            // calculate the CRC on the unccompressed data  (before writing)
            if (crc.HasValue())
                crc.SlurpBlock(buffer, offset, count);

            if (Mode == StreamMode.Undefined)
            {
                Mode = StreamMode.Writer;
            }
            else if (Mode != StreamMode.Writer)
            {
                throw new IOException("Cannot Write after Reading.");
            }

            if (count == 0)
                return;

            // first reference of z property will initialize the private var _z
            z.InputBuffer = buffer;
            Codec.NextIn = offset;
            Codec.AvailableBytesIn = count;
            bool done = false;
            do
            {
                Codec.OutputBuffer = workingBuffer;
                Codec.NextOut = 0;
                Codec.AvailableBytesOut = WorkingBuffer.Length;
                int rc = (_wantCompress)
                    ? Codec.Deflate(FlushMode)
                    : Codec.Inflate(FlushMode);
                if (rc != ZlibConstants.Z_OK && rc != ZlibConstants.Z_STREAM_END)
                    throw new IOException((_wantCompress ? "de" : "in") + "flating: " + Codec.Message);

                //if (_workingBuffer.Length - _z.AvailableBytesOut > 0)
                StreamBase.Write(WorkingBuffer, 0, WorkingBuffer.Length - Codec.AvailableBytesOut);

                done = Codec.AvailableBytesIn == 0 && Codec.AvailableBytesOut != 0;

                // If GZIP and de-compress, we're done when 8 bytes remain.
                if (Flavor == ZlibStreamFlavor.GZip && !_wantCompress)
                    done = (Codec.AvailableBytesIn == 8 && Codec.AvailableBytesOut != 0);

            }
            while (!done);
        }



        private void finish()
        {
            if (Codec.IsNull()) return;

            if (Mode == StreamMode.Writer)
            {
                bool done = false;
                do
                {
                    Codec.OutputBuffer = workingBuffer;
                    Codec.NextOut = 0;
                    Codec.AvailableBytesOut = WorkingBuffer.Length;
                    int rc = (_wantCompress)
                        ? Codec.Deflate(FlushType.Finish)
                        : Codec.Inflate(FlushType.Finish);

                    if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)
                    {
                        string verb = (_wantCompress ? "de" : "in") + "flating";
                        if (Codec.Message.IsNull())
                            throw new IOException(String.Format("{0}: (rc = {1})", verb, rc));
                        else
                            throw new IOException(verb + ": " + Codec.Message);
                    }

                    if (WorkingBuffer.Length - Codec.AvailableBytesOut > 0)
                    {
                        StreamBase.Write(WorkingBuffer, 0, WorkingBuffer.Length - Codec.AvailableBytesOut);
                    }

                    done = Codec.AvailableBytesIn == 0 && Codec.AvailableBytesOut != 0;
                    // If GZIP and de-compress, we're done when 8 bytes remain.
                    if (Flavor == ZlibStreamFlavor.GZip && !_wantCompress)
                        done = (Codec.AvailableBytesIn == 8 && Codec.AvailableBytesOut != 0);

                }
                while (!done);

                Flush();

                // workitem 7159
                if (Flavor == ZlibStreamFlavor.GZip)
                {
                    if (_wantCompress)
                    {
                        // Emit the GZIP trailer: CRC32 and  size mod 2^32
                        int c1 = crc.Crc32Result;
                        StreamBase.Write(BitConverter.GetBytes(c1), 0, 4);
                        int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);
                        StreamBase.Write(BitConverter.GetBytes(c2), 0, 4);
                    }
                    else
                    {
                        throw new IOException("Writing with decompression is not supported.");
                    }
                }
            }
            // workitem 7159
            else if (Mode == StreamMode.Reader)
            {
                if (Flavor == ZlibStreamFlavor.GZip)
                {
                    if (!_wantCompress)
                    {
                        // workitem 8501: handle edge case (decompress empty stream)
                        if (Codec.TotalBytesOut == 0L)
                            return;

                        // Read and potentially verify the GZIP trailer:
                        // CRC32 and size mod 2^32
                        byte[] trailer = new byte[8];

                        // workitems 8679 & 12554
                        if (Codec.AvailableBytesIn < 8)
                        {
                            // Make sure we have read to the end of the stream
                            Array.Copy(Codec.InputBuffer, Codec.NextIn, trailer, 0, Codec.AvailableBytesIn);
                            int bytesNeeded = 8 - Codec.AvailableBytesIn;
                            int bytesRead = StreamBase.Read(trailer,
                                                         Codec.AvailableBytesIn,
                                                         bytesNeeded);
                            if (bytesNeeded != bytesRead)
                            {
                                throw new IOException(String.Format("Missing or incomplete GZIP trailer. Expected 8 bytes, got {0}.",
                                                                      Codec.AvailableBytesIn + bytesRead));
                            }
                        }
                        else
                        {
                            Array.Copy(Codec.InputBuffer, Codec.NextIn, trailer, 0, trailer.Length);
                        }

                        Int32 crc32_expected = BitConverter.ToInt32(trailer, 0);
                        Int32 crc32_actual = crc.Crc32Result;
                        Int32 isize_expected = BitConverter.ToInt32(trailer, 4);
                        Int32 isize_actual = (Int32)(Codec.TotalBytesOut & 0x00000000FFFFFFFF);

                        //if (crc32_actual != crc32_expected)
                        //    throw new IOException(String.Format("Bad CRC32 in GZIP trailer. (actual({0:X8})!=expected({1:X8}))", crc32_actual, crc32_expected));

                        //if (isize_actual != isize_expected)
                        //    throw new IOException(String.Format("Bad size in GZIP trailer. (actual({0})!=expected({1}))", isize_actual, isize_expected));

                    }
                    else
                    {
                        throw new IOException("Reading with compression is not supported.");
                    }
                }
            }
        }


        private void end()
        {
            if (z.IsNull())
                return;
            if (_wantCompress)
            {
                Codec.EndDeflate();
            }
            else
            {
                Codec.EndInflate();
            }
            Codec = null;
        }


        public override void Close()
        {
            if (StreamBase.IsNull()) return;

            Flush();

            try
            {
                finish();
            }
            finally
            {
                end();
                if (!LeaveOpen) StreamBase.Close();
                StreamBase = null;
            }
        }

        public override void Flush()
        {
            StreamBase.Flush();
        }

        public override System.Int64 Seek(System.Int64 offset, System.IO.SeekOrigin origin)
        {
            throw new NotImplementedException();
            //_outStream.Seek(offset, origin);
        }
        public override void SetLength(System.Int64 value)
        {
            StreamBase.SetLength(value);
        }

        private bool nomoreinput = false;



        private string ReadZeroTerminatedString()
        {
            var list = new System.Collections.Generic.List<byte>();
            bool done = false;
            do
            {
                // workitem 7740
                int n = StreamBase.Read(Buffer1, 0, 1);
                if (n != 1)
                    throw new IOException("Unexpected EOF reading GZIP header.");
                else
                {
                    if (Buffer1[0] == 0)
                        done = true;
                    else
                        list.Add(Buffer1[0]);
                }
            } while (!done);
            byte[] a = list.ToArray();
            return GZipNativeStream.Iso8859.GetString(a, 0, a.Length);
        }


        private int _ReadAndValidateGzipHeader()
        {
            int totalBytesRead = 0;
            // read the header on the first read
            byte[] header = new byte[10];
            int n = StreamBase.Read(header, 0, header.Length);

            // workitem 8501: handle edge case (decompress empty stream)
            if (n == 0)
                return 0;

            if (n != 10)
                throw new IOException("Not a valid GZIP stream.");

            if (header[0] != 0x1F || header[1] != 0x8B || header[2] != 8)
                throw new IOException("Bad GZIP header.");

            int timet = BitConverter.ToInt32(header, 4);
            GzipMtime = GZipNativeStream.UnixEpoch.AddSeconds(timet);
            totalBytesRead += n;
            if ((header[3] & 0x04) == 0x04)
            {
                // read and discard extra field
                n = StreamBase.Read(header, 0, 2); // 2-byte length field
                totalBytesRead += n;

                Int16 extraLength = (Int16)(header[0] + header[1] * 256);
                byte[] extra = new byte[extraLength];
                n = StreamBase.Read(extra, 0, extra.Length);
                if (n != extraLength)
                    throw new IOException("Unexpected end-of-file reading GZIP header.");
                totalBytesRead += n;
            }
            if ((header[3] & 0x08) == 0x08)
                GzipFileName = ReadZeroTerminatedString();
            if ((header[3] & 0x10) == 0x010)
                GzipComment = ReadZeroTerminatedString();
            if ((header[3] & 0x02) == 0x02)
                Read(Buffer1, 0, 1); // CRC16, ignore

            return totalBytesRead;
        }



        public override int Read(byte[] buffer, int offset, int count)
        {
            // According to MS documentation, any implementation of the IO.Stream.Read function must:
            // (a) throw an exception if offset & count reference an invalid part of the buffer,
            //     or if count < 0, or if buffer is null
            // (b) return 0 only upon EOF, or if count = 0
            // (c) if not EOF, then return at least 1 byte, up to <count> bytes

            if (Mode == StreamMode.Undefined)
            {
                if (!this.StreamBase.CanRead) throw new IOException("The stream is not readable.");
                // for the first read, set up some controls.
                Mode = StreamMode.Reader;
                // (The first reference to _z goes through the private accessor which
                // may initialize it.)
                z.AvailableBytesIn = 0;
                if (Flavor == ZlibStreamFlavor.GZip)
                {
                    GzipHeaderByteCount = _ReadAndValidateGzipHeader();
                    // workitem 8501: handle edge case (decompress empty stream)
                    if (GzipHeaderByteCount == 0)
                        return 0;
                }
            }

            if (Mode != StreamMode.Reader)
            {
                throw new IOException("Cannot Read after Writing.");
            }

            if (count == 0) return 0;
            if (nomoreinput && _wantCompress) return 0;  // workitem 8557
            if (buffer.IsNull()) throw new ArgumentNullException("buffer");
            if (count < 0) throw new ArgumentOutOfRangeException("count");
            if (offset < buffer.GetLowerBound(0)) throw new ArgumentOutOfRangeException("offset");
            if ((offset + count) > buffer.GetLength(0)) throw new ArgumentOutOfRangeException("count");

            int rc = 0;

            // set up the output of the deflate/inflate codec:
            Codec.OutputBuffer = buffer;
            Codec.NextOut = offset;
            Codec.AvailableBytesOut = count;

            // This is necessary in case _workingBuffer has been resized. (new byte[])
            // (The first reference to _workingBuffer goes through the private accessor which
            // may initialize it.)
            Codec.InputBuffer = workingBuffer;

            do
            {
                // need data in _workingBuffer in order to deflate/inflate.  Here, we check if we have any.
                if ((Codec.AvailableBytesIn == 0) && (!nomoreinput))
                {
                    // No data available, so try to Read data from the captive stream.
                    Codec.NextIn = 0;
                    Codec.AvailableBytesIn = StreamBase.Read(WorkingBuffer, 0, WorkingBuffer.Length);
                    if (Codec.AvailableBytesIn == 0)
                        nomoreinput = true;

                }
                // we have data in InputBuffer; now compress or decompress as appropriate
                rc = (_wantCompress)
                    ? Codec.Deflate(FlushMode)
                    : Codec.Inflate(FlushMode);

                if (nomoreinput && (rc == ZlibConstants.Z_BUF_ERROR))
                    return 0;

                if (rc != ZlibConstants.Z_OK && rc != ZlibConstants.Z_STREAM_END)
                    throw new IOException(String.Format("{0}flating:  rc={1}  msg={2}", (_wantCompress ? "de" : "in"), rc, Codec.Message));

                if ((nomoreinput || rc == ZlibConstants.Z_STREAM_END) && (Codec.AvailableBytesOut == count))
                    break; // nothing more to read
            }
            //while (_z.AvailableBytesOut == count && rc == ZlibConstants.Z_OK);
            while (Codec.AvailableBytesOut > 0 && !nomoreinput && rc == ZlibConstants.Z_OK);


            // workitem 8557
            // is there more room in output?
            if (Codec.AvailableBytesOut > 0)
            {
                if (rc == ZlibConstants.Z_OK && Codec.AvailableBytesIn == 0)
                {
                    // deferred
                }

                // are we completely done reading?
                if (nomoreinput)
                {
                    // and in compression?
                    if (_wantCompress)
                    {
                        // no more input data available; therefore we flush to
                        // try to complete the read
                        rc = Codec.Deflate(FlushType.Finish);

                        if (rc != ZlibConstants.Z_OK && rc != ZlibConstants.Z_STREAM_END)
                            throw new IOException(String.Format("Deflating:  rc={0}  msg={1}", rc, Codec.Message));
                    }
                }
            }


            rc = (count - Codec.AvailableBytesOut);

            // calculate CRC after reading
            if (crc.HasValue())
                crc.SlurpBlock(buffer, offset, rc);

            return rc;
        }



        public override System.Boolean CanRead
        {
            get { return this.StreamBase.CanRead; }
        }

        public override System.Boolean CanSeek
        {
            get { return this.StreamBase.CanSeek; }
        }

        public override System.Boolean CanWrite
        {
            get { return this.StreamBase.CanWrite; }
        }

        public override System.Int64 Length
        {
            get { return StreamBase.Length; }
        }

        public override long Position
        {
            get { throw new NotImplementedException(); }
            set { throw new NotImplementedException(); }
        }

        internal enum StreamMode
        {
            Writer,
            Reader,
            Undefined,
        }


        public static void CompressString(String s, Stream compressor)
        {
            byte[] uncompressed = System.Text.Encoding.UTF8.GetBytes(s);
            using (compressor)
            {
                compressor.Write(uncompressed, 0, uncompressed.Length);
            }
        }

        public static void CompressBuffer(byte[] b, Stream compressor)
        {
            // workitem 8460
            using (compressor)
            {
                compressor.Write(b, 0, b.Length);
            }
        }

        public static String UncompressString(byte[] compressed, Stream decompressor)
        {
            // workitem 8460
            byte[] working = new byte[1024];
            var encoding = System.Text.Encoding.UTF8;
            using (var output = new MemoryStream())
            {
                using (decompressor)
                {
                    int n;
                    while ((n = decompressor.Read(working, 0, working.Length)) != 0)
                    {
                        output.Write(working, 0, n);
                    }
                }

                // reset to allow read from start
                output.Seek(0, SeekOrigin.Begin);
                var sr = new StreamReader(output, encoding);
                return sr.ReadToEnd();
            }
        }

        public static byte[] UncompressBuffer(byte[] compressed, Stream decompressor)
        {
            // workitem 8460
            byte[] working = new byte[1024];
            using (var output = new MemoryStream())
            {
                using (decompressor)
                {
                    int n;
                    while ((n = decompressor.Read(working, 0, working.Length)) != 0)
                    {
                        output.Write(working, 0, n);
                    }
                }
                return output.ToArray();
            }
        }
    }
}
