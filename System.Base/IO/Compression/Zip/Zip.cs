//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

namespace System.IO.Compression
{
    /// <summary>
    /// https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html
    /// </summary>
    [CLSCompliant(false)]
    public class Zip
    {
        protected ZipRecordEnd ZipEnd;
        protected ZipEntryCollection Items;
        protected internal DirectoryInfo Folder;

        public ZipEntryCollection Entries
        {
            get { return Items ?? (Items = new ZipEntryCollection(this)); }
        }

        public static Zip Open(string path)
        {
            using (var s = File.OpenRead(path))
            {
                return Open(s);
            }
        }

        public static Zip Open(byte[] bytes)
        {
            using (var s = new MemoryStream(bytes))
            {
                return Open(s);
            }
        }

        public static Zip Open(Stream s)
        {
            var value = new Zip();
            value.Read(s);
            return value;
        }

        public void Read(string path)
        {
            using (Stream s = File.OpenRead(path))
            {
                Read(s);
            }
        }

        public void Read(Stream s)
        {
            using (var reader = new BinaryReader(s))
            {
                Read(reader);
            }
        }

        public void Read(BinaryReader reader)
        {
            while (true)
            {
                var e = new ZipEntry(this);

                if (e.Read(reader))
                {
                    Entries.Add(e);
                }
                else
                {
                    break;
                }
            }

            while (true)
            {
                var e = new ZipHeader();

                if (e.Read(reader, false) == false)
                {
                    ZipEnd = new ZipRecordEnd();
                    ZipEnd.Read(reader);
                    break;
                }
            }
        }

        public void Write(string path)
        {
            using (Stream output = File.Create(path))
            {
                Write(output);
            }
        }

        public void Write(Stream output)
        {
            using (var writer = new BinaryWriter(output))
            {
                Write(writer);
            }
        }

        public void Write(BinaryWriter writer)
        {
            if (Items.HasValue())
            {
                ZipEnd = new ZipRecordEnd();

                foreach (ZipEntry e in Entries)
                {
                    e.Header.OffsetLocalHeader = (uint)writer.BaseStream.Position;
                    e.Write(writer);
                }

                ZipEnd.DiskEntries = (ushort)Entries.Count;
                ZipEnd.TotalEntries = (ushort)Entries.Count;
                ZipEnd.DiskOffset = (uint)writer.BaseStream.Position;

                foreach (ZipEntry e in Entries)
                {
                    e.Header.Write(writer, false);
                }

                ZipEnd.DirectorySize = (uint)(writer.BaseStream.Position - ZipEnd.DiskOffset);
                ZipEnd.Write(writer);
            }
        }

        public byte[] ToArray()
        {
            using (var output = new MemoryStream())
            {
                Write(output);
                return output.ToArray();
            }
        }
    }
}
