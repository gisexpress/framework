//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.CoordinateSystems;
using System.Geometries;

namespace System.Transformations
{
    public class MatrixTransform : IMathTransform
    {
        public MatrixTransform()
        {
            Reset();
        }

        public MatrixTransform(double[] elements)
            : this(elements[0], elements[1], elements[2], elements[3], elements[4], elements[5])
        {
        }

        public MatrixTransform(double m11, double m12, double m21, double m22, double dx, double dy)
        {
            M11 = m11;
            M12 = m12;
            M21 = m21;
            M22 = m22;

            OffsetX = dx;
            OffsetY = dy;
        }

        protected double M11;
        protected double M12;
        protected double M21;
        protected double M22;

        public int GetSrid()
        {
            return 0;
        }

        public double[] Elements
        {
            get { return new[] { M11, M12, M21, M22, OffsetX, OffsetY }; }
        }

        protected double Determinant
        {
            get { return M11 * M22 - M12 * M21; }
        }

        public bool IsNull
        {
            get { return ((M11 - 1.0).IsZero() && M12.IsZero() && M21.IsZero() && (M22 - 1.0).IsZero() && OffsetX.IsZero() && OffsetY.IsZero()); }
        }

        public bool IsInvertible
        {
            get { return !Determinant.IsZero(); }
        }

        public double OffsetX
        {
            get;
            set;
        }

        public double OffsetY
        {
            get;
            set;
        }

        public bool Invert()
        {
            double m11, m12, m21, m22, dx, dy;
            double d = Determinant;

            if (!d.IsZero())
            {
                m11 = M22 / d;
                m12 = -(M12 / d);
                m21 = -(M21 / d);
                m22 = M11 / d;

                dx = (M21 * OffsetY - M22 * OffsetX) / d;
                dy = (M12 * OffsetX - M11 * OffsetY) / d;

                M11 = m11;
                M12 = m12;
                M21 = m21;
                M22 = m22;

                OffsetX = dx;
                OffsetY = dy;

                return true;
            }

            return false;
        }

        public void Multiply(MatrixTransform matrix)
        {
            Multiply(matrix, this);
        }

        public void Multiply(MatrixTransform matrix, bool append)
        {
            if (append)
            {
                Multiply(this, matrix);
            }
            else
            {
                Multiply(matrix, this);
            }
        }

        void Multiply(MatrixTransform m1, MatrixTransform m2)
        {
            double m11 = m1.M11 * m2.M11 + m1.M12 * m2.M21;
            double m12 = m1.M11 * m2.M12 + m1.M12 * m2.M22;
            double m21 = m1.M21 * m2.M11 + m1.M22 * m2.M21;
            double m22 = m1.M21 * m2.M12 + m1.M22 * m2.M22;
            double dx = m1.OffsetX * m2.M11 + m1.OffsetY * m2.M21 + m2.OffsetX;
            double dy = m1.OffsetX * m2.M12 + m1.OffsetY * m2.M22 + m2.OffsetY;

            M11 = m11;
            M12 = m12;
            M21 = m21;
            M22 = m22;
            OffsetX = dx;
            OffsetY = dy;
        }

        public void Reset()
        {
            M11 = 1.0;
            M12 = 0.0;
            M21 = 0.0;
            M22 = 1.0;
            OffsetX = 0.0;
            OffsetY = 0.0;
        }

        public void Rotate(double angle)
        {
            Rotate(angle, false);
        }

        public void Rotate(double angle, bool append)
        {
            double m11, m12, m21, m22, dx, dy;

            double radians = angle.DegreeToRadian();
            double cos = Math.Cos(radians);
            double sin = Math.Sin(radians);

            if (append)
            {
                m11 = M11 * cos - M12 * sin;
                m12 = M11 * sin + M12 * cos;
                m21 = M21 * cos - M22 * sin;
                m22 = M21 * sin + M22 * cos;
                dx = OffsetX * cos - OffsetY * sin;
                dy = OffsetX * sin + OffsetY * cos;

                M11 = m11;
                M12 = m12;
                M21 = m21;
                M22 = m22;
                OffsetX = dx;
                OffsetY = dy;
            }
            else
            {
                m11 = cos * M11 + sin * M21;
                m12 = cos * M12 + sin * M22;
                m21 = cos * M21 - sin * M11;
                m22 = cos * M22 - sin * M12;

                M11 = m11;
                M12 = m12;
                M21 = m21;
                M22 = m22;
            }
        }

        public void RotateAt(double angle, ICoordinate point)
        {
            RotateAt(angle, point.X, point.Y, false);
        }

        public void RotateAt(double angle, double x, double y)
        {
            RotateAt(angle, x, y, false);
        }

        public void RotateAt(double angle, double x, double y, bool append)
        {
            if (append)
            {
                Translate(-x, -y);
                Rotate(angle, true);
                Translate(x, y);
            }
            else
            {
                Translate(x, y);
                Rotate(angle);
                Translate(-x, -y);
            }
        }

        public void Scale(double scaleX, double scaleY)
        {
            Scale(scaleX, scaleY, false);
        }

        public void Scale(double scaleX, double scaleY, bool append)
        {
            if (append)
            {
                M11 *= scaleX;
                M12 *= scaleY;
                M21 *= scaleX;
                M22 *= scaleY;
                OffsetX *= scaleX;
                OffsetY *= scaleY;
            }
            else
            {
                M11 *= scaleX;
                M12 *= scaleX;
                M21 *= scaleY;
                M22 *= scaleY;
            }
        }

        public void ScaleAt(double scaleX, double scaleY, ICoordinate center)
        {
            ScaleAt(scaleX, scaleY, center.X, center.Y);
        }

        public void ScaleAt(double scaleX, double scaleY, double x, double y)
        {
            Translate(x, y);
            Scale(scaleX, scaleY);
            Translate(-x, -y);
        }

        public void Shear(double shearX, double shearY)
        {
            Shear(shearX, shearY, false);
        }

        public void Shear(double shearX, double shearY, bool append)
        {
            if (append)
            {
                double m11 = M11 + M12 * shearX;
                double m12 = M11 * shearY + M12;
                double m21 = M21 + M22 * shearX;
                double m22 = M21 * shearY + M22;
                double dx = OffsetX + OffsetY * shearX;
                double dy = OffsetX * shearY + OffsetY;

                M11 = m11;
                M12 = m12;
                M21 = m21;
                M22 = m22;
                OffsetX = dx;
                OffsetY = dy;
            }
            else
            {
                double m11 = M11 + M21 * shearY;
                double m12 = M12 + M22 * shearY;
                double m21 = M11 * shearX + M21;
                double m22 = M12 * shearX + M22;

                M11 = m11;
                M12 = m12;
                M21 = m21;
                M22 = m22;
            }
        }

        public void Translate(double offsetX, double offsetY)
        {
            Translate(offsetX, offsetY, false);
        }

        public void Translate(double offsetX, double offsetY, bool append)
        {
            if (append)
            {
                OffsetX += offsetX;
                OffsetY += offsetY;
            }
            else
            {
                OffsetX += offsetX * M11 + offsetY * M21;
                OffsetY += offsetX * M12 + offsetY * M22;
            }
        }

        public bool Transform(double[] points)
        {
            double x = points[0];
            double y = points[1];

            if (Transform(ref x, ref y))
            {
                points[0] = x;
                points[1] = y;

                return true;
            }

            return false;
        }

        public bool Transform(ref double x, ref double y)
        {
            double a, b;

            a = x * M11 + y * M21 + OffsetX;
            b = x * M12 + y * M22 + OffsetY;

            x = a;
            y = b;

            return true;
        }

        public double Transform(double[] values, int index)
        {
            if (index == 0)
            {
                return values[0] * M11 + values[1] * M21 + OffsetX;
            }
            else
            {
                return values[0] * M12 + values[1] * M22 + OffsetY;
            }
        }

        public bool Transform(ICoordinate c)
        {
            double[] values = c.GetValues();

            double x = values[0];
            double y = values[1];

            values[0] = x * M11 + y * M21 + OffsetX;
            values[1] = x * M12 + y * M22 + OffsetY;

            c.SetValues(values);

            return true;
        }

        public override int GetHashCode()
        {
            return (int)(M11 + M12 + M21 + M22 + OffsetX + OffsetY);
        }

        public override bool Equals(Object obj)
        {
            var other = (obj as MatrixTransform);

            if (other.HasValue())
            {
                return ((other.M11 - M11).IsZero() && (other.M12 - M12).IsZero() && (other.M21 - M21).IsZero() && (other.M22 - M22).IsZero() && (other.OffsetX - OffsetX).IsZero() && (other.OffsetY - OffsetY).IsZero());
            }

            return false;
        }

        object ICloneable.Clone()
        {
            return Clone();
        }

        public MatrixTransform Clone()
        {
            return (MatrixTransform)MemberwiseClone();
        }
    }
}
