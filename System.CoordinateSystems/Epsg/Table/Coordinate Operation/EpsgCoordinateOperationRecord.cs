//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Data;

namespace System.CoordinateSystems.Epsg
{
    internal class EpsgCoordinateOperationRecord : EpsgRecord
    {
        public override object GetKey()
        {
            return GetCode();
        }

        public override bool IsValid()
        {
            switch (GetMethod())
            {
                case EpsgOperationMethod.GeocentricTranslations:
                case EpsgOperationMethod.PositionVectorTransformation:
                    return base.IsValid();
            }

            return false;
        }

        /// <summary>
        /// Unique code (integer) of the coordinate operation, which is unique over this table; primary key.
        /// </summary>
        public int GetCode()
        {
            return (int)base["Code"];
        }

        /// <summary>
        /// Unique name of the coordinate operation.
        /// </summary>
        public string GetName()
        {
            return (string)base["Name"];
        }

        /// <summary>
        /// The type of coordinate operation: "conversion", "transformation" or "concatenated operation". 
        /// A Map Projection is a "Conversion". Concatenated operations consist of several single operations in a prescribed order.
        /// </summary>
        public new string GetType()
        {
            return (string)base["Type"];
        }

        /// <summary>
        /// Source (or input) coordinate reference system for an operation; system to be transformed or converted. 
        /// Mandatory for transformations and concatenated operations, not required for conversions.
        /// </summary>
        public int GetSourceCRS()
        {
            return (int)base["SourceCRS"];
        }

        /// <summary>
        /// Target (or output) coordinate reference system for  an operation;  system for end result. 
        /// Mandatory for transformations and concatenated operations, not required for conversions.
        /// </summary>
        public int GetTargetCRS()
        {
            return (int)base["TargetCRS"];
        }

        /// <summary>
        /// Not required for conversions. 
        /// The version of the  transformation between these source and target coordinate reference systems.
        /// For  transformations (datum or concatenated) may act as a secondary triple key with source and target coordinate ref systems.
        /// </summary>
        public string GetCoordTfmVersion()
        {
            return (string)base["CoordTfmVersion"];
        }

        /// <summary>
        /// Not required for conversions.
        /// The counter for the transformation between this source and this target coordinate systems.
        /// In EPSG prior to v5.0 acted as the version identifier.  Retained only for purposes of backward compatibility.
        /// </summary>
        public short GetVariant()
        {
            return (short)base["Variant"];
        }

        /// <summary>
        /// The code of the Area of Use for which the operation is considered valid.
        /// </summary>
        public int GetAreaCode()
        {
            return (int)base["AreaCode"];
        }

        /// <summary>
        /// The applicability of the Coordinate Operation.
        /// </summary>
        public string GetCoordOpScope()
        {
            return (string)base["CoordOpScope"];
        }

        /// <summary>
        /// A indicative number indicating the loss of accuracy in metres that applying the transformation might bring to target coordinates.
        /// For conversions, which are considered exact by definition, the value is 0.
        /// </summary>
        public float GetTfmAccuracy()
        {
            return (float)base["TfmAccuracy"];
        }

        public EpsgOperationMethod GetMethod()
        {
            return (EpsgOperationMethod)GetOperationMethodCode();
        }

        /// <summary>
        /// Foreign key to coordinate operation method.
        /// </summary>
        public int GetOperationMethodCode()
        {
            return (int)base["OperationMethodCode"];
        }

        /// <summary>
        /// Unit of measure of the input or source coordinate differences in a polynomial operation.
        /// Often different from the UOM of the coordinate reference system.
        /// </summary>
        public int GetSourceCoordDiffUoMCode()
        {
            return (int)base["SourceCoordDiffUoMCode"];
        }

        /// <summary>
        /// Unit of measure of the output or target coordinate differences in a polynomial operation.
        /// Often different from the UOM of the coordinate reference system.
        /// </summary>
        public int GetTargetCoordDiffUoMCode()
        {
            return (int)base["TargetCoordDiffUoMCode"];
        }

        /// <summary>
        /// Switch to indicate whether operation data can be made public.  "Yes" or "No". Default is Yes.
        /// </summary>
        public bool GetShowOperation()
        {
            return (bool)base["ShowOperation"];
        }

        public override void Read(IDataReader reader)
        {
            base["Code"] = reader.Get<int>("COORD_OP_CODE");
            base["Name"] = reader.Get<string>("COORD_OP_NAME");
            base["Type"] = reader.Get<string>("COORD_OP_TYPE");
            base["SourceCRS"] = reader.Get<int>("SOURCE_CRS_CODE");
            base["TargetCRS"] = reader.Get<int>("TARGET_CRS_CODE");
            base["CoordTfmVersion"] = reader.Get<string>("COORD_TFM_VERSION");
            base["Variant"] = reader.Get<short>("COORD_OP_VARIANT");
            base["AreaCode"] = reader.Get<int>("AREA_OF_USE_CODE");
            base["CoordOpScope"] = reader.Get<string>("COORD_OP_SCOPE");
            base["TfmAccuracy"] = reader.Get<float>("COORD_OP_ACCURACY");
            base["OperationMethodCode"] = reader.Get<int>("COORD_OP_METHOD_CODE");
            base["SourceCoordDiffUoMCode"] = reader.Get<int>("UOM_CODE_SOURCE_COORD_DIFF");
            base["TargetCoordDiffUoMCode"] = reader.Get<int>("UOM_CODE_TARGET_COORD_DIFF");
            base["ShowOperation"] = reader.Get<bool>("SHOW_OPERATION");
            base.Read(reader);
        }

        public override IDictionary<string, TypeCode> GetProperties()
        {
            var properties = base.GetProperties();

            properties.Add("Code", TypeCode.Int32);
            properties.Add("Name", TypeCode.String);
            properties.Add("Type", TypeCode.String);
            properties.Add("SourceCRS", TypeCode.Int32);
            properties.Add("TargetCRS", TypeCode.Int32);
            properties.Add("CoordTfmVersion", TypeCode.String);
            properties.Add("Variant", TypeCode.Int16);
            properties.Add("AreaCode", TypeCode.Int32);
            properties.Add("CoordOpScope", TypeCode.String);
            properties.Add("TfmAccuracy", TypeCode.Single);
            properties.Add("OperationMethodCode", TypeCode.Int32);
            properties.Add("SourceCoordDiffUoMCode", TypeCode.Int32);
            properties.Add("TargetCoordDiffUoMCode", TypeCode.Int32);
            properties.Add("ShowOperation", TypeCode.Boolean);

            return properties;
        }
    }

    public enum EpsgOperationMethod : int
    {
        Unknown = 0,
        GeocentricTranslations = 9603,
        PositionVectorTransformation = 9606
    }
}
