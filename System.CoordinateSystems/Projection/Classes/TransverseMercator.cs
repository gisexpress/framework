//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Geometries;

namespace System.CoordinateSystems
{
    internal class TransverseMercator : ProjectionCls
    {
        public TransverseMercator(string name, Authority authority, IEllipsoid ellipsoid, ILinearUnit unit, ProjectionParameterCollection parameters)
            : base(name, authority, ellipsoid, unit, parameters)
        {
            ScaleFactor = this[ProjectionParameterKind.Scale_Factor];
            CenterLongitude = this[ProjectionParameterKind.Central_Meridian].DegreeToRadian();
            CenterLatitude = this[ProjectionParameterKind.Latitude_Of_Origin].DegreeToRadian();
            FalseEasting = this[ProjectionParameterKind.False_Easting] * Ellipsoid.AxisUnit.MetersPerUnit;
            FalseNorthing = this[ProjectionParameterKind.False_Northing] * Ellipsoid.AxisUnit.MetersPerUnit;

            Eccentricity = 1.0 - (Ellipsoid.SemiMinorAxis / Ellipsoid.SemiMajorAxis).Pow();
            Eccentricity0 = E0Fn(Eccentricity);
            Eccentricity1 = E1Fn(Eccentricity);
            Eccentricity2 = E2Fn(Eccentricity);
            Eccentricity3 = E3Fn(Eccentricity);
            Ml0 = Ellipsoid.SemiMajorAxis * Mlfn(Eccentricity0, Eccentricity1, Eccentricity2, Eccentricity3, CenterLatitude);
            EccentricitySp = Eccentricity / (1.0 - Eccentricity);
        }


        protected readonly double CenterLatitude;
        protected readonly double CenterLongitude;
        protected readonly double ScaleFactor;
        protected readonly double FalseEasting;
        protected readonly double FalseNorthing;
        protected readonly double Eccentricity0;
        protected readonly double Eccentricity1;
        protected readonly double Eccentricity2;
        protected readonly double Eccentricity3;
        protected readonly double Eccentricity;
        protected readonly double EccentricitySp;
        protected readonly double Ml0;

        public override IMathTransform CreateTransform(int sourceSrid, int targetSrid)
        {
            return new MathTransform(sourceSrid, targetSrid, DegreesToMeters, MetersToDegrees);
        }

        bool DegreesToMeters(ICoordinate c)
        {
            double lon = c.X.DegreeToRadian();
            double lat = c.Y.DegreeToRadian();

            double sinValue = Math.Sin(lat);
            double cosValue = Math.Cos(lat);

            double al = cosValue * AdjustLon(lon - CenterLongitude);
            double als = al.Pow();
            double cos = EccentricitySp * cosValue.Pow();
            double tq = Math.Tan(lat);
            double t = tq.Pow();
            double con = 1.0 - Eccentricity * sinValue.Pow();
            double n = Ellipsoid.SemiMajorAxis / con.Sqrt();
            double ml = Ellipsoid.SemiMajorAxis * Mlfn(Eccentricity0, Eccentricity1, Eccentricity2, Eccentricity3, lat);

            double x = ScaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + cos + als / 20.0 * (5.0 - 18.0 * t + t.Pow() + 72.0 * cos - 58.0 * EccentricitySp))) + FalseEasting;
            double y = ScaleFactor * (ml - Ml0 + n * tq * (als * (0.5 + als / 24.0 * (5.0 - t + 9.0 * cos + 4.0 * cos.Pow() + als / 30.0 * (61.0 - 58.0 * t + t.Pow() + 600.0 * cos - 330.0 * EccentricitySp))))) + FalseNorthing;

            c.SetValues(x / Unit.MetersPerUnit, y / Unit.MetersPerUnit);

            return true;
        }

        bool MetersToDegrees(ICoordinate c)
        {
            int i;
            double delta_phi;	                // Difference between longitudes
            double ce, cs, t, ts, n, r, d, ds;	// Temporary variables
            long max_iter = 6;			        // Maximun number of iterations

            double x = c.X * Unit.MetersPerUnit - FalseEasting;
            double y = c.Y * Unit.MetersPerUnit - FalseNorthing;

            double con = (Ml0 + y / ScaleFactor) / Ellipsoid.SemiMajorAxis;
            double phi = con;

            for (i = 0; ; i++)
            {
                delta_phi = ((con + Eccentricity1 * Math.Sin(2.0 * phi) - Eccentricity2 * Math.Sin(4.0 * phi) + Eccentricity3 * Math.Sin(6.0 * phi)) / Eccentricity0) - phi;
                phi += delta_phi;

                if (delta_phi.Abs() <= Epsilon)
                {
                    break;
                }

                if (i >= max_iter)
                {
                    return false;
                }
            }

            if (phi.Abs() < AppConstants.HalfPI)
            {
                double sin = Math.Sin(phi);
                double cos = Math.Cos(phi);
                double tan = Math.Tan(phi);

                ce = EccentricitySp * cos.Pow();
                cs = ce.Pow();
                t = tan.Pow();
                ts = t.Pow();
                con = 1.0 - Eccentricity * sin.Pow();
                n = Ellipsoid.SemiMajorAxis / con.Sqrt();
                r = n * (1.0 - Eccentricity) / con;
                d = x / (n * ScaleFactor);
                ds = d.Pow();

                double lat = phi - (n * tan * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t + 10.0 * ce - 4.0 * cs - 9.0 * EccentricitySp - ds / 30.0 * (61.0 + 90.0 * t + 298.0 * ce + 45.0 * ts - 252.0 * EccentricitySp - 3.0 * cs)));
                double lon = AdjustLon(CenterLongitude + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t + ce - ds / 20.0 * (5.0 - 2.0 * ce + 28.0 * t - 3.0 * cs + 8.0 * EccentricitySp + 24.0 * ts))) / cos));

                c.SetValues(lon.RadianToDegree(), lat.RadianToDegree());
            }
            else
            {
                c.SetValues((AppConstants.HalfPI * y.Sign()).RadianToDegree(), CenterLongitude.RadianToDegree());
            }

            return true;
        }
    }
}