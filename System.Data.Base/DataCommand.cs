//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.ComponentModel;
using System.CoordinateSystems;
using System.Geometries;
using System.Linq;
using System.Xml;

namespace System.Data
{
    [ToolboxItem(false)]
    public abstract class DataCommand : XmlFolderElement, IDisposable
    {
        static DataCommand()
        {
            TypeFactory.Default.Register<ITransactionLog, TransactionLog>();
        }

        protected internal DataCommand(string prefix, string localName, string namespaceURI, XmlDocument doc) : base(prefix, localName, namespaceURI, doc)
        {
            TransactionLog = TypeFactory.Default.Create<ITransactionLog>();
        }

        int? Id;
        int? Srs;
        ITransactionLog Log;
        bool IsTransactional;

        public string CommandText
        {
            get;
            set;
        }

        public ITransactionLog TransactionLog
        {
            get { return Log; }
            set
            {
                if (Log.HasValue())
                {
                    Log.BeginTransaction -= OnBeginTransactionLog;
                    Log.EndTransaction -= OnEndTransactionLog;
                }

                Log = value;

                if (value.HasValue())
                {
                    value.BeginTransaction += OnBeginTransactionLog;
                    value.EndTransaction += OnEndTransactionLog;
                }
            }
        }

        public int Srid
        {
            get { return (Srs ?? (Srs = GetSrid())).Value; }
        }

        protected virtual int GetSrid()
        {
            return 0;
        }

        public virtual IEnvelope GetBounds()
        {
            return default;
        }

        public int GetNextId()
        {
            if (Id.HasValue)
            {
                return (++Id).Value;
            }

            Id = GetFeatures().Cast<IKeyedObject>().Select(e => { int.TryParse(e.Name, out int n); return n; }).DefaultIfEmpty(0).Max();
            return GetNextId();
        }

        public virtual IFeature NewFeature()
        {
            return default;
        }

        public virtual IFeature FindFeature(object featureId)
        {
            return default;
        }

        public IEnumerable<IFeature> GetFeatures()
        {
            return GetFeatures(default);
        }

        public virtual IEnumerable<IFeature> GetFeatures(IEnvelope bounds)
        {
            yield break;
        }

        public virtual int ExecuteInsert(IFeature feature)
        {
            if (OnInsertFeature(feature))
            {
                AddTransactionLog(feature);
                return 1;
            }

            return 0;
        }

        public int ExecuteUpdate(IFeature feature)
        {
            if (OnUpdateFeature(feature))
            {
                AddTransactionLog(feature);
                return 1;
            }

            return 0;
        }

        public int ExecuteDelete(IFeature feature)
        {
            if (OnDeleteFeature(feature))
            {
                AddTransactionLog(feature);
                return 1;
            }

            return 0;
        }

        protected virtual bool OnInsertFeature(IFeature feature)
        {
            var e = (XmlElementBase)feature;
            e.Remove();
            AppendChild(e);
            return true;
        }

        protected virtual bool OnUpdateFeature(IFeature feature)
        {
            var e = (XmlElementBase)feature;
            e.Remove();
            AppendChild(e);
            return true;
        }

        protected virtual bool OnDeleteFeature(IFeatureRecord feature)
        {
            return ((XmlElementBase)feature).Remove();
        }

        protected virtual void OnBeginTransactionLog()
        {
            IsTransactional = true;
        }

        protected virtual void OnEndTransactionLog()
        {
            IsTransactional = false;
        }

        protected void AddTransactionLog(IFeature feature)
        {
            if (IsTransactional || TransactionLog == null)
            {
                return;
            }

            TransactionLog.Add(feature);
        }

        public virtual void Dispose()
        {
            GC.SuppressFinalize(this);
        }
    }
}
