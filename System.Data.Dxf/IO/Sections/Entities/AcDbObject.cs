//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2017. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Geometries;

namespace System.Data.Dxf
{
    internal abstract class AcDbObject
    {
        static AcDbObject()
        {
            Types = new Dictionary<string, Type>();
            Types.Add("3DFACE", null);
            Types.Add("3DSOLID", null);
            Types.Add("ACAD_PROXY_ENTITY", null);
            Types.Add("ATTDEF", null);
            Types.Add("ATTRIB", null);
            Types.Add("BODY", null);
            Types.Add("HELIX", null);
            Types.Add("IMAGE", null);
            Types.Add("LEADER", null);
            Types.Add("LIGHT", null);
            Types.Add("MESH", null);
            Types.Add("MLEADERSTYLE", null);
            Types.Add("OLEFRAME", null);
            Types.Add("OLE2FRAME", null);
            Types.Add("RAY", null);
            Types.Add("REGION", null);
            Types.Add("SECTION", null);
            Types.Add("SEQEND", null);
            Types.Add("SHAPE", null);
            Types.Add("SOLID", null);
            Types.Add("SUN", null);
            Types.Add("SURFACE", null);
            Types.Add("TABLE", null);
            Types.Add("TOLERANCE", null);
            Types.Add("TRACE", null);
            Types.Add("UNDERLAY", null);
            Types.Add("VERTEX", null);
            Types.Add("WIPEOUT", null);
            Types.Add("XLINE", null);
            Types.Add("MLINE", null);
            Types.Add("POINT", null);
            Types.Add("DIMENSION", null);
            Types.Add("MLEADER", null);
            Types.Add("ARC", typeof(AcDbArc));
            Types.Add("CIRCLE", typeof(AcDbCircle));
            Types.Add("ELLIPSE", typeof(AcDbEllipse));
            Types.Add("LINE", typeof(AcDbLine));
            Types.Add("POLYLINE", typeof(AcDbPolyline));
            Types.Add("LWPOLYLINE", typeof(AcDbPolyline));
            Types.Add("SPLINE", null);
            Types.Add("MTEXT", null);
            Types.Add("HATCH", null);
            Types.Add("INSERT", typeof(AcDbBlockReference));
            Types.Add("VIEWPORT", null);
        }

        internal static Dictionary<string, Type> Types;

        public DxfDocument Document
        {
            get;
            internal set;
        }

        public string LayerName
        {
            get;
            set;
        }

        public bool IsVisible
        {
            get;
            set;
        }

        public string LineTypeName
        {
            get;
            set;
        }

        /// <summary>
        /// Color name. 
        /// The group code cannot be used by custom entities for their own data because the group code is reserved for AcDbEntity, 
        /// class-level color data and AcDbEntity, class-level transparency data
        /// </summary>
        public string ColorName
        {
            get;
            set;
        }

        /// <summary>
        /// Color number (present if not BYLAYER); zero indicates the BYBLOCK (floating) color; 
        /// 256 indicates BYLAYER; a negative value indicates that the layer is turned off (optional)
        /// </summary>
        public int ColorNumber
        {
            get;
            set;
        }

        /// <summary>
        /// A 24-bit color value that should be dealt with in terms of bytes with values of 0 to 255. 
        /// The lowest byte is the blue value, the middle byte is the green value, and the third byte is the red value. 
        /// The top byte is always 0. 
        /// </summary>
        public int ColorValue
        {
            get;
            set;
        }

        /// <summary>
        /// Transparency value. 
        /// The group code cannot be used by custom entities for their own data because the group code is reserved for AcDbEntity, class-level color data and AcDbEntity, class-level transparency data.
        /// </summary>
        public float Transparency
        {
            get;
            set;
        }

        /// <summary>
        /// 0 = Casts and receives shadows
        /// 1 = Casts shadows
        /// 2 = Receives shadows
        /// 3 = Ignores shadows
        /// </summary>
        public byte ShadowMode
        {
            get;
            set;
        }

        public abstract IGeometry GetGeometry();

        public void Read(DxfReader reader)
        {
            while (reader.Read() && reader.GroupCode != 0)
            {
                OnRead(reader);
            }
        }

        protected virtual void OnRead(DxfReader reader)
        {
            switch (reader.GroupCode)
            {
                case -1:
                    // APP: entity name (changes each time a drawing is opened)
                    break;
                case 008:
                    LayerName = reader.GetString();
                    break;
                case 006:
                    LineTypeName = reader.GetString();
                    break;
                case 060:
                    IsVisible = reader.GetByte() != 1;
                    break;
                case 062:
                    ColorNumber = reader.GetInt32();
                    break;
                case 420:
                    ColorValue = reader.GetInt32();
                    break;
                case 430:
                    ColorName = reader.GetString();
                    break;
                case 440:
                    Transparency = reader.GetSingle();
                    break;
                case 284:
                    ShadowMode = reader.GetByte();
                    break;
                case 005: // Handle
                case 048: // Linetype scale (optional) 
                case 067: // Absent or zero indicates entity is in model space. 1 indicates entity is in paper space (optional).
                case 092: // Number of bytes in the proxy entity graphics represented in the sub-sequent 310 groups, which are binary chunk records (optional)
                case 100: // Subclass marker (AcDbEntity)
                case 102: // Start of application-defined group “{application_name” (optional)
                case 210: // Extrusion direction (optional; default = 0, 0, 1)
                case 220:
                case 230:
                case 310: // Proxy entity graphics data (multiple lines; 256 characters max. per line)(optional)
                case 330: // Soft-pointer ID/handle to owner dictionary (optional)
                case 347: // Hard-pointer ID/handle to material object (present if not BYLAYER) 
                case 360: // Hard-owner ID/handle to owner dictionary (optional)
                case 370: // Lineweight enum value. Stored and moved around as a 16-bit integer.
                case 390: // Hard-pointer ID/handle to the plot style object
                case 410: // APP: layout tab name
                    break;
            }
        }
    }
}
