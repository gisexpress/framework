//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;

namespace System.Geometries
{
    internal class EllipseComponent : RectangleComponent
    {
        public EllipseComponent(IApplicationComponentDesigner designer, Ellipse value)
            : base(designer, value)
        {
            AllowAlignments = false;
        }

        protected bool Vertical;
        protected double Width;
        protected double Height;
        protected ICoordinate Center;

        protected override bool IsClosed
        {
            get { return false; }
        }

        public override void AddProperties(PropertyDescriptorCollection properties)
        {
            foreach (PropertyDescriptor property in properties)
            {
                var item = property as IPropertyDescriptor;

                if (item.HasValue())
                {
                    item.IsReadOnly = !Detached && !IsDragging;
                }
            }

            base.AddProperties(properties);
        }

        protected override void OnCoordinateBeginEdit(IApplicationComponent component, ICoordinate c)
        {
            Center = null;

            base.OnCoordinateBeginEdit(component, c);

            if (IsDragging)
            {
                Width = Value.Width;
                Height = Value.Height;
                component.EditCompleted += CenterEditCompleted;
            }
        }

        protected override void OnRectangleBeginEdit(ICoordinate c)
        {
            Center = Value.GetCentroid();
            Vertical = Center.X.IsEquivalent(c.X);
        }

        protected override bool OnValidateRect(ICoordinate location)
        {
            if (!Detached && Center.HasValue())
            {
                double dx = Vertical ? Value.Width / 2.0 : Center.Distance(location);
                double dy = Vertical ? Center.Distance(location) : Value.Height / 2.0;

                Value.StartPoint.SetValues(Center.X - dx, Center.Y - dy);
                Value.EndPoint.SetValues(Center.X + dx, Center.Y + dy);

                location.SetValues(Vertical ? Center.X : location.X < Center.X ? Value.StartPoint.X : Value.EndPoint.X, Vertical ? location.Y < Center.Y ? Value.StartPoint.Y : Value.EndPoint.Y : Center.Y);

                return true;
            }

            return base.OnValidateRect(location);
        }

        protected override void OnCoordinatePaint(ApplicationComponentPaintEventArgs e)
        {
            if (Value.NumPoints() > 1)
            {
                PointF p1 = Designer.Transform.WorldToClient(Value.StartPoint);
                PointF p2 = Designer.Transform.WorldToClient(Value.EndPoint);

                float minx = Math.Min(p1.X, p2.X);
                float miny = Math.Min(p1.Y, p2.Y);
                float maxx = Math.Max(p1.X, p2.X);
                float maxy = Math.Max(p1.Y, p2.Y);

                if (Detached)
                {
                    e.Path.Reset();
                }

                e.Graphics.DrawRectangle(ApplicationAppereance.Pens.SnapHotTrack, minx, miny, maxx - minx, maxy - miny);
            }

            base.OnCoordinatePaint(e);
        }

        protected void CenterEditCompleted(ApplicationComponentEditCompletedEventArgs e)
        {
            if (e.Action == ComponentEditCompleteAction.Complete)
            {
                var center = e.Component.Value as ICoordinate;

                Value.StartPoint.SetValues(center.X - Width / 2.0, center.Y + Height / 2.0);
                Value.EndPoint.SetValues(center.X + Width / 2.0, center.Y - Height / 2.0);
            }
        }
    }
}
