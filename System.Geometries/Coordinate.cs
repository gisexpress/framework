//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.CoordinateSystems;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.IO;
using System.Linq;
using System.Xml;

namespace System.Geometries
{
    internal class Coordinate : ICoordinate, IEnumerable<double>
    {
        public Coordinate()
        {
            SetNull();
        }

        public Coordinate(double x, double y)
        {
            SetValues(x, y);
        }

        public Coordinate(double x, double y, double z)
        {
            SetValues(x, y, z);
        }

        public Coordinate(ICoordinate c)
        {
            SetValues(c.GetValues());
        }

        public Coordinate(BinaryReader reader)
            : this(reader.ReadDouble(), reader.ReadDouble())
        {
        }

        public static event PointVisitedEventHandler PointVisited;

        protected int HashCode;
        protected double[] Items;

        public static Coordinate Empty
        {
            get { return new Coordinate(); }
        }

        public bool IsEmpty()
        {
            return Items == null || Items.Length == 0;
        }

        public bool DesignMode
        {
            get;
            private set;
        }

        public void BeginInit()
        {
        }

        public void EndInit()
        {
        }

        public int Index
        {
            get
            {
                if (Collection.HasValue())
                {
                    return Collection.IndexOf(this);
                }

                return -1;
            }
        }

        public ICoordinateCollection Collection
        {
            get;
            set;
        }

        public int Dimension
        {
            get { return IsEmpty() ? 0 : Items.Length; }
        }

        public virtual double X
        {
            get
            {
                return Items[0];
            }
            set
            {
                if (IsEmpty())
                {
                    SetValues(value, 0.0);
                }
                else
                {
                    Items.SetValue(value, 0);
                    SetValues(Items);
                }
            }
        }

        public virtual double Y
        {
            get
            {
                return Items[1];
            }
            set
            {
                if (IsEmpty())
                {
                    SetValues(0.0, value);
                }
                else
                {
                    Items.SetValue(value, 1);
                    SetValues(Items);
                }
            }
        }

        public virtual double Z
        {
            get { return Dimension > 2 ? Items[2] : 0.0; }
            set
            {
                if (Dimension > 2)
                {
                    Items[2] = value;
                }
            }
        }

        public double Angle(ICoordinate other)
        {
            return Angle(other, true);
        }

        public double Angle(ICoordinate other, bool normalize)
        {
            if (IsEmpty() || other.IsEmpty())
            {
                return 0.0;
            }

            double angle = Math.Atan2(other.Y - Y, other.X - X);

            if (normalize)
            {
                return (angle + AppConstants.TwoPI) % AppConstants.TwoPI;
            }

            return angle;
        }

        //public double Azimuth(ICoordinate other)
        //{
        //    return GeometryFactory.GetAzimuth(this, other);
        //}

        public double Distance(ICoordinate other)
        {
            if (other.IsEmpty())
            {
                return 0.0;
            }

            if (Dimension > 2 && other.Dimension > 2)
            {
                return Distance(other.X, other.Y, other.Z);
            }

            return Distance(other.X, other.Y);
        }

        public double Distance(double x, double y)
        {
            if (IsEmpty())
            {
                return 0.0;
            }

            return ((X - x).Pow() + (Y - y).Pow()).Sqrt();
        }

        public double Distance(double x, double y, double z)
        {
            if (IsEmpty())
            {
                return 0.0;
            }

            return ((X - x).Pow() + (Y - y).Pow() + (Z - z).Pow()).Sqrt();
        }

        public double GetLength()
        {
            return GetLengthSquared().Sqrt();
        }

        public double GetLengthSquared()
        {
            return X.Pow() + Y.Pow() + Z.Pow();
        }

        public IEnvelope GetBounds()
        {
            return GetBounds(1e-4);
        }

        public IEnvelope GetBounds(double distance)
        {
            if (IsEmpty())
            {
                return default;
            }

            return new Envelope(X - distance, X + distance, Y - distance, Y + distance);
        }

        public ICoordinate GetPointAt(double width, double height, double angle)
        {
            return new Coordinate(X + (width * Math.Cos(angle)), Y + (height * Math.Sin(angle)));
        }

        public ICoordinate[] GetFilletPoints(double width, double height, double startAngle, double endAngle)
        {
            return GetFilletPoints(width, height, startAngle, endAngle, AppConstants.QuadrantSegments);
        }

        public ICoordinate[] GetFilletPoints(double width, double height, double startAngle, double endAngle, int quadrantSegments)
        {
            return EnumerateFilletPoints(width, height, startAngle, endAngle, quadrantSegments).ToArray();
        }

        protected IEnumerable<ICoordinate> EnumerateFilletPoints(double width, double height, double startAngle, double endAngle, int quadrantSegments)
        {
            var sweepAngle = endAngle - startAngle;
            var length = (int)((sweepAngle.Abs() / (AppConstants.HalfPI / quadrantSegments)) + 0.5);

            if (length > 0)
            {
                double angleN = sweepAngle / length;

                yield return GetPointAt(width, height, startAngle);

                for (int n = 1; n < length; n++)
                {
                    yield return GetPointAt(width, height, startAngle + angleN * n);
                }

                yield return GetPointAt(width, height, endAngle);
            }
            else
            {
                yield return GetPointAt(width, height, startAngle);
                yield return GetPointAt(width, height, (startAngle + endAngle) / 2.0);
                yield return GetPointAt(width, height, endAngle);
            }
        }

        public bool Transform(IMathTransform transform)
        {
            return transform.Transform(this);
        }

        public double[] GetValues()
        {
            return Items;
        }

        public void SetNull()
        {
            Items = null;
        }

        public void SetAltitude(double value)
        {
            SetAltitude(value, false);
        }

        public void SetAltitude(double value, bool append)
        {
            SetValues(X, Y, (append ? Z : 0.0) + value);
        }

        public void SetValues(params double[] values)
        {
            double[] newItems = values.ReducePrecision();

            if (Collection.HasValue())
            {
                Collection.Set(this, newItems);
            }

            if (Items.HasValue() && Items.Length > values.Length)
            {
                newItems.CopyTo(Items, 0);
            }
            else
            {
                Items = newItems;
            }

            HashCode = GetHashCode(X, Y, Z, false);
        }

        public void Normalize()
        {
            double m = Math.Abs(X);
            double absy = Math.Abs(Y);
            double absz = Math.Abs(Z);

            if (absy > m)
            {
                m = absy;
            }

            if (absz > m)
            {
                m = absz;
            }

            X /= m;
            Y /= m;
            Z /= m;

            double length = GetLength();

            X /= length;
            Y /= length;
            Z /= length;
        }

        public IEnumerable<ILineSegment> GetSegments()
        {
            return Collection.GetSegments(this);
        }

        public IApplicationComponent GetComponent(IApplicationComponentDesigner designer)
        {
            IApplicationComponent component = new CoordinateComponent(designer, this);

            DesignMode = true;
            component.EditCompleted += OnEditCompleted;

            return component;
        }

        protected void OnEditCompleted(ApplicationComponentEditCompletedEventArgs e)
        {
            e.Component.EditCompleted -= OnEditCompleted;
            DesignMode = false;
        }

        public static ICoordinate Create(double x, double y)
        {
            return new Coordinate(x, y);
        }

        public static ICoordinate Create(double x, double y, double z)
        {
            return new Coordinate(x, y, z);
        }

        public ICoordinate Add(ICoordinate other)
        {
            return new Coordinate(X + other.X, Y + other.Y);
        }

        public ICoordinate Subtract(ICoordinate other)
        {
            return new Coordinate(X - other.X, Y - other.Y);
        }

        public ICoordinate Multipy(double value)
        {
            return new Coordinate(X * value, Y * value);
        }

        public ICoordinate Multipy(ICoordinate other)
        {
            return new Coordinate(X * other.X, Y * other.Y);
        }

        public ICoordinate Divide(double value)
        {
            if (!value.IsZero())
            {
                return new Coordinate(X / value, Y / value);
            }

            return this;
        }

        public ICoordinate Divide(ICoordinate other)
        {
            return new Coordinate(X / other.X, Y / other.Y);
        }

        public static Coordinate operator +(Coordinate self, Coordinate other)
        {
            return new Coordinate(self.X + other.X, self.Y + other.Y);
        }

        public static Coordinate operator -(Coordinate self, Coordinate other)
        {
            return new Coordinate(self.X - other.X, self.Y - other.Y);
        }

        public static void Reverse(ICoordinate c1, ICoordinate c2)
        {
            ICoordinate c = c1.Clone();

            c2.CopyTo(c1);
            c.CopyTo(c2);
        }

        public void AppendToPath(Graphics g, GraphicsPath path, Func<ICoordinate, PointF> transform, float radius, bool raiseEvents)
        {
            PointF location = transform(this);

            AppendToPath(g, path, location, radius);

            if (raiseEvents)
            {
                InvokeVisited(this, location);
            }
        }

        public static void AppendToPath(Graphics g, GraphicsPath path, PointF location, float radius)
        {
            path.StartFigure();
            path.AddLine(location.X - radius, location.Y, location.X, location.Y - radius);
            path.AddLine(location.X, location.Y - radius, location.X + radius, location.Y);
            path.AddLine(location.X + radius, location.Y, location.X, location.Y + radius);
            path.CloseFigure();
        }

        internal static void InvokeVisited(ICoordinate value, PointF point)
        {
            if (value.HasValue())
            {
                InvokeVisited(value, point, false, false);
            }
        }

        internal static void InvokeVisited(ICoordinate value, Func<ICoordinate, PointF> transform)
        {
            if (value.HasValue())
            {
                InvokeVisited(value, transform(value), false, false);
            }
        }

        internal static void InvokeVisited(ICoordinate value, Func<ICoordinate, PointF> transform, bool isMidPoint, bool isCenter)
        {
            if (value.HasValue())
            {
                InvokeVisited(value, transform(value), isMidPoint, isCenter);
            }
        }

        internal static void InvokeVisited(ICoordinate value, PointF point, bool isMidPoint, bool isCenter)
        {
            if (PointVisited.HasValue() && value.HasValue())
            {
                var e = new PointVisitedEventArgs
                {
                    Point = point,
                    Value = value,
                    IsCenter = isCenter,
                    IsMidPoint = isMidPoint,
                };

                PointVisited(e);
            }
        }

        public void Write(BinaryWriter writer)
        {
            writer.Write(X);
            writer.Write(Y);
        }

        public void LoadXml(XmlNode node)
        {
            throw new NotImplementedException();

            //foreach (string name in reader.ReadElements())
            //{
            //    switch (name)
            //    {
            //        case "X":
            //            X = XmlConvert.ToDouble(reader.ReadString());
            //            break;
            //        case "Y":
            //            Y = XmlConvert.ToDouble(reader.ReadString());
            //            break;
            //        case "Z":
            //            SetAltitude(XmlConvert.ToDouble(reader.ReadString()));
            //            break;
            //    }
            //}
        }

        public void SaveXml(XmlNode node)
        {
            throw new NotImplementedException();

            //writer.WriteElementString("X", XmlConvert.ToString(X));
            //writer.WriteElementString("Y", XmlConvert.ToString(Y));

            //if (Dimension > 2)
            //{
            //    writer.WriteElementString("Z", XmlConvert.ToString(Z));
            //}
        }

        public int CompareTo(object obj)
        {
            return CompareTo(obj as ICoordinate);
        }

        public int CompareTo(ICoordinate other)
        {
            if (this != other)
            {
                if (Dimension > 2 && other.Dimension > 2)
                {
                    if (Z > other.Z) return 1;
                    if (Z < other.Z) return -1;
                }

                if (X > other.X) return 1;
                if (X < other.X) return -1;

                if (Y > other.Y) return 1;
                if (Y < other.Y) return -1;
            }

            return 0;
        }

        public int CompareTo(ICoordinate other, int octant)
        {
            int sx = X.CompareTo(other.X);
            int sy = Y.CompareTo(other.Y);

            switch (octant)
            {
                case 0: return CompareSign(sx, sy);
                case 1: return CompareSign(sy, sx);
                case 2: return CompareSign(sy, -sx);
                case 3: return CompareSign(-sx, sy);
                case 4: return CompareSign(-sx, -sy);
                case 5: return CompareSign(-sy, -sx);
                case 6: return CompareSign(-sy, sx);
                case 7: return CompareSign(sx, -sy);
            }

            return 0;
        }

        static int CompareSign(int sign, int signOther)
        {
            if (sign < 0) return -1;
            if (sign > 0) return 1;

            if (signOther < 0) return -1;
            if (signOther > 0) return 1;

            return 0;
        }

        public int GetOctant(ICoordinate other)
        {
            Debug.Assert(!IsEquivalent(other));

            double dxs = other.X - X;
            double dys = other.Y - Y;

            double dx = dxs.Abs();
            double dy = dys.Abs();

            if (dxs >= 0.0)
            {
                if (dys >= 0.0)
                {
                    if (dx >= dy)
                    {
                        return 0;
                    }

                    return 1;
                }

                if (dx >= dy)
                {
                    return 7;
                }

                return 6;
            }

            if (dys >= 0.0)
            {
                if (dx >= dy)
                {
                    return 3;
                }

                return 2;
            }

            if (dx >= dy)
            {
                return 4;
            }

            return 5;
        }

        public bool IsEquivalent(ICoordinate other)
        {
            if (other == null)
            {
                return false;
            }

            return HashCode == other.GetHashCode();
        }

        public bool IsEquivalent(double x, double y)
        {
            return IsEquivalent(x, y, 0.0);
        }

        public bool IsEquivalent(double x, double y, double z)
        {
            if (IsEmpty())
            {
                return false;
            }

            return HashCode == GetHashCode(x, y, z, true);
        }

        public object GetValue(GeometryProperty property)
        {
            if (IsEmpty())
            {
                return default;
            }

            switch (property)
            {
                case GeometryProperty.X:
                    return X;

                case GeometryProperty.Y:
                    return Y;

                case GeometryProperty.Altitude:
                    return Z;
            }

            return default;
        }

        public void SetValue(GeometryProperty property, object value)
        {
            switch (property)
            {
                case GeometryProperty.X:
                    X = (double)value;
                    break;
                case GeometryProperty.Y:
                    Y = (double)value;
                    break;
            }
        }

        public void CopyTo(ICoordinate other)
        {
            other.SetValues(Items);
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            if (IsEmpty())
            {
                base.GetHashCode();
            }

            return HashCode;
        }

        static int GetHashCode(double x, double y, double z, bool reducePrecision)
        {
            unchecked
            {
                int n = Hash.Seed;

                double a = reducePrecision ? x.ReducePrecision() : x;
                double b = reducePrecision ? y.ReducePrecision() : y;

                if (a < 0.0) n *= 31;
                if (b < 0.0) n *= 41;

                n = n * Hash.Step + a.GetHashCode();
                n = n * Hash.Step + b.GetHashCode();

                return n;
            }
        }

        object ICloneable.Clone()
        {
            return Clone();
        }

        public ICoordinate Clone()
        {
            return Clone(default);
        }

        public ICoordinate Clone(ICoordinateCollection owner)
        {
            var c = new Coordinate { Collection = owner };

            if (IsEmpty())
            {
                return c;
            }

            c.SetValues(Items.Clone() as double[]);

            return c;
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public IEnumerator<double> GetEnumerator()
        {
            yield return X;
            yield return Y;

            if (Dimension > 2)
            {
                yield return Z;
            }
        }

        public override string ToString()
        {
            if (IsEmpty())
            {
                return default;
            }

            return ToString(" ");
        }

        public string ToString(string separator)
        {
            return string.Join(separator, this);
        }

        public void Dispose()
        {
            Items = null;
            GC.SuppressFinalize(this);
        }
    }
}
