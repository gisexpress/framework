//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.ComponentModel.Design;
using System.CoordinateSystems;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Xml;

namespace System.Geometries
{
    [DebuggerDisplay("{ToString()}")]
    internal class CoordinateCollection : XmlCoordinatesElement, ICoordinateCollection
    {
        public CoordinateCollection(XmlDocument document, params ICoordinate[] coordinates) : base(document)
        {
            Add(coordinates);
        }

        public CoordinateCollection(XmlDocument document) : base(document)
        {
        }

        public IGeometryFactory Factory
        {
            get { return OwnerDocument.Factory; }
        }

        public bool IsClockwise()
        {
            return Clockwise >= 0;
        }

        public virtual void BeginInit()
        {
            OnChanged();
        }

        public virtual void EndInit()
        {
        }

        public virtual double GetArea()
        {
            if (IsRing())
            {
                double area = SignedArea;

                if (!IsClosed)
                {
                    area += ItemSignedArea(EndPoint, StartPoint);
                }

                return area.Abs() / 2.0;
            }

            return 0.0;
        }

        public virtual double GetLength()
        {
            return Length;
        }

        public virtual double GetAngle()
        {
            return Geometry.GetAngle(this).Abs();
        }

        public virtual double GetAzimuth()
        {
            return Factory.GetAzimuth(EndPoint, StartPoint);
        }

        public double GetDistance(int start, int end)
        {
            return Get(start).Distance(Get(end));
        }

        public virtual ICoordinate GetCentroid()
        {
            if (IsRing() && AreaSum.IsValid())
            {
                try
                {
                    if (!IsClosed)
                    {
                        ItemCentroid(EndPoint, StartPoint, true);
                    }

                    return OnCalculateCentroid(this);
                }
                finally
                {
                    if (!IsClosed)
                    {
                        ItemCentroid(EndPoint, StartPoint, false);
                    }
                }
            }

            return default;
        }

        protected virtual ICoordinate OnCalculateCentroid(CoordinateCollection collection)
        {
            if (AreaSum.IsZero())
            {
                return default;
            }

            return new Coordinate(CenterX / AreaSum / 3.0, CenterY / AreaSum / 3.0, CenterZ / AreaSum / 3.0);
        }

        public void Snap(ICoordinateCollection target)
        {
            OnSnap(target);
        }

        protected virtual void OnSnap(ICoordinateCollection target)
        {
            foreach (ICoordinate c in target)
            {
                int n = 0;

                foreach (ILineSegment segment in GetSegments())
                {
                    n++;

                    if (segment.P0.IsEquivalent(c))
                    {
                        continue;
                    }

                    if (segment.P1.IsEquivalent(c))
                    {
                        continue;
                    }

                    if (segment.Distance(c) <= 1e-8)
                    {
                        InsertItem(n, c);
                        break;
                    }
                }
            }
        }

        public bool IsOnLine(ICoordinate c)
        {
            return IsOnLine(GetEnumerator(), c, 1e-8);
        }

        public bool IsOnLine(ICoordinate c, double tolerance)
        {
            return IsOnLine(GetEnumerator(), c, tolerance);
        }

        protected virtual bool IsOnLine(IEnumerator<ICoordinate> e, ICoordinate c, double tolerance)
        {
            var segment = new LineSegment();

            if (e.MoveNext())
            {
                segment.P0 = e.Current;

                while (e.MoveNext())
                {
                    segment.P1 = e.Current;

                    if (segment.Distance(c) <= tolerance)
                    {
                        return true;
                    }

                    segment.P0 = segment.P1;
                }
            }

            return false;
        }

        public ICoordinate Add()
        {
            ICoordinate c;
            InsertItem(Count, c = Coordinate.Empty);
            return c;
        }

        public void Add(ICoordinate c)
        {
            InsertItem(Count, c);
        }

        public void Add(IEnumerable<ICoordinate> coordinates)
        {
            foreach (ICoordinate c in coordinates)
            {
                InsertItem(Count, c);
            }
        }

        public ICoordinate Add(double x, double y)
        {
            var c = new Coordinate(x, y);
            InsertItem(Count, c);
            return c;
        }

        public ICoordinate Add(double x, double y, double z)
        {
            var c = new Coordinate(x, y, z);
            InsertItem(Count, c);
            return c;
        }

        public virtual void Normalize(bool clockwise)
        {
            for (int i = 0; i < Count / 2; i++)
            {
                int j = Count - 1 - i;

                if (Items[i].IsEquivalent(Items[j]))
                {
                    continue;
                }

                if (Items[i].CompareTo(Items[j]) > 0)
                {
                    List.Reverse();
                }

                break;
            }
        }

        public ICoordinate GetPointMin()
        {
            ICoordinate c = StartPoint;

            for (int i = 1; i < Count; i++)
            {
                if (c.CompareTo(List[i]) > 0)
                {
                    c = List[i];
                }
            }

            return c;
        }

        public void Reverse()
        {
            bool ring = IsRing();

            if (ring)
            {
                Items.Remove(EndPoint);
            }

            var points = new Coordinate[Count];

            Items.Reverse();
            Items.CopyTo(points);

            ClearItems();
            Add(points);

            if (ring)
            {
                Add(StartPoint.X, StartPoint.Y);
            }

            OnChanged();
        }

        public void Scroll(ICoordinate point)
        {
            int i = Items.IndexOf(point);

            if (i >= 0)
            {
                bool ring = IsRing();

                if (ring)
                {
                    Items.Remove(EndPoint);
                }

                var list = Items.ToList();
                var points = new Coordinate[Count];

                list.CopyTo(i, points, 0, Count - i);
                list.CopyTo(0, points, Count - i, i);

                ClearItems();
                Add(points);

                if (ring)
                {
                    Add(StartPoint.X, StartPoint.Y);
                }

                OnChanged();
            }
        }

        public virtual IEnvelope GetBounds()
        {
            if (Bounds == null && Count > 0)
            {
                IEnumerator<ICoordinate> e = GetEnumerator();

                if (e.MoveNext())
                {
                    bool hasAltitude = e.Current.Dimension > 2;

                    double minx = e.Current.X;
                    double miny = e.Current.Y;
                    double minz = e.Current.Z;
                    double maxx = minx;
                    double maxy = miny;
                    double maxz = minz;

                    while (e.MoveNext())
                    {
                        minx = Math.Min(minx, e.Current.X);
                        miny = Math.Min(miny, e.Current.Y);
                        maxx = Math.Max(maxx, e.Current.X);
                        maxy = Math.Max(maxy, e.Current.Y);

                        if (hasAltitude)
                        {
                            minz = Math.Min(minz, e.Current.Z);
                            maxz = Math.Max(maxz, e.Current.Z);
                        }
                    }

                    Bounds = Factory.Create<IEnvelope>();

                    if (hasAltitude)
                    {
                        Bounds.Init(minx, maxx, miny, maxy, minz, maxz);
                    }
                    else
                    {
                        Bounds.Init(minx, maxx, miny, maxy);
                    }
                }
            }

            return Bounds;
        }

        public ICoordinate Get(int index)
        {
            return Items[index];
        }

        public double GetAltitude()
        {
            return StartPoint.Z;
        }

        public void SetAltitude(double value)
        {
            SetAltitude(value, false);
        }

        public virtual void SetAltitude(double value, bool append)
        {
            if (Items.Count > 1)
            {
                foreach (ICoordinate c in Items.Skip(1))
                {
                    c.SetAltitude(value, append);
                }
            }

            if (!IsEmpty())
            {
                StartPoint.SetAltitude(value, append);
            }
        }

        public bool Read(ITokenEnumerator e)
        {
            return OnRead(e);
        }

        protected virtual bool OnRead(ITokenEnumerator e)
        {
            if (e.ReadNext('('))
            {
                var nz = default(NumberToken);

                while (true)
                {
                    if (e.ReadNumber(out NumberToken nx) && e.ReadNumber(out NumberToken ny))
                    {
                        if (e.MoveNext())
                        {
                            nz = e.Current as NumberToken;

                            if (nz.HasValue() && !e.MoveNext())
                            {
                                return false;
                            }
                        }

                        double x = Convert.ToDouble(nx.Value);
                        double y = Convert.ToDouble(ny.Value);
                        double z = nz.HasValue() ? Convert.ToDouble(nz.Value) : 0.0;

                        if (z.IsZero())
                        {
                            Add(x, y);
                        }
                        else
                        {
                            Add(x, y, z);
                        }

                        if (e.Current.Equals(')'))
                        {
                            return true;
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
            }

            return false;
        }

        //public virtual void SaveXml(XmlElementBase e)
        //{
        //    if (Count > 0)
        //    {
        //        e.Set(Constants.Xml.Coordinates).InnerText = Items.Select(c => c.ToString(", ")).Join(" ");
        //    }
        //}

        public void Write(Stream output)
        {
            using (var writer = new BinaryWriter(output))
            {
                OnWrite(writer);
            }
        }

        public void Write(BinaryWriter writer)
        {
            OnWrite(writer);
        }

        protected virtual void OnWrite(BinaryWriter writer)
        {
            Write(writer, this);
        }

        public static void Write(BinaryWriter writer, CoordinateCollection points)
        {
            writer.Write(points.Count);

            foreach (Coordinate c in points)
            {
                c.Write(writer);
            }
        }

        public void Transform(IMathTransform transform)
        {
            bool closed = IsClosed;

            if (closed)
            {
                IsClosed = false;
            }

            Items.ForEach(c => transform.Transform(c));

            if (closed)
            {
                IsClosed = true;
            }
        }

        public ILineString ToLineString()
        {
            ILineString value = Factory.Create<ILineString>();
            value.Coordinates = this;
            return value;
        }

        public ICoordinate[] ToArray()
        {
            return Items.ToArray();
        }

        public ICoordinate[] ToCopyArray()
        {
            return Items.Select(c => c.Clone()).ToArray();
        }

        public virtual object[] GetObjects()
        {
            return Items.Select(c => c.GetValues()).ToArray();
        }

        public virtual void SetObjects(object[] values)
        {
            Add(values.Cast<object[]>().Select(item => CreateCoordinate(item)));
        }

        public ICoordinate CreateCoordinate(object[] values)
        {
            ICoordinate c = new Coordinate();
            c.SetValues(values.Select(item => Convert.ToDouble(item)).ToArray());
            return c;
        }

        public bool IsEquivalent(ICoordinateCollection other, ArrayComparison comparisonType)
        {
            return IsEquivalent(other, 0, comparisonType);
        }

        public virtual bool IsEquivalent(ICoordinateCollection other, int compareAt, ArrayComparison comparisonType)
        {
            return ToArray().IsEquivalent(other.ToArray(), GetHashCode, compareAt, comparisonType);
        }

        public virtual IEnumerable<ICoordinate> GetCoordinates()
        {
            return Items;
        }

        public virtual IEnumerable<ICoordinate> GetEditableCoordinates(IApplicationComponent component)
        {
            return Items;
        }

        public virtual IEnumerable<ILineSegment> GetSegments()
        {
            var e = GetEnumerator();

            if (e.MoveNext())
            {
                var segment = new LineSegment
                {
                    P0 = e.Current
                };

                while (e.MoveNext())
                {
                    segment.P1 = e.Current;

                    yield return segment;

                    segment.P0 = e.Current;
                }
            }
        }

        public virtual IEnumerable<ILineSegment> GetSegments(ICoordinate c)
        {
            int n = IndexOf(c);

            if (n >= 0)
            {
                if (n > 0)
                {
                    yield return new LineSegment(Get(n - 1), c);
                }

                if (n + 1 < Count)
                {
                    yield return new LineSegment(c, Get(n + 1));
                }
            }
        }

        public int GetHashCode(ICoordinate c)
        {
            return c.GetHashCode();
        }

        public override int GetHashCode()
        {
            if (IsEmpty())
            {
                return base.GetHashCode();
            }

            return Hash.Get(Items);
        }

        public bool Equals(ICoordinate x, ICoordinate y)
        {
            return x.IsEquivalent(y);
        }

        public PaintStyle Style
        {
            get;
            set;
        }

        public object Tag
        {
            get;
            set;
        }

        protected override void InsertItem(int index, ICoordinate c)
        {
            c.Collection = this;
            base.InsertItem(index, c);
        }

        public new ICoordinateCollection Clone()
        {
            return new CoordinateCollection(OwnerDocument) { ToCopyArray() };
        }

        public virtual string ToText()
        {
            if (IsEmpty())
            {
                return "(Empty)";
            }

            return string.Concat('(', Items.Select(c => c.ToString()).Join(", "), ')');
        }

        public override string ToString()
        {
            return ToText();
        }

        public new IEnumerator<ICoordinate> GetEnumerator()
        {
            return Items.GetEnumerator();
        }
    }
}
