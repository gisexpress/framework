//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.CoordinateSystems;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Xml;

namespace System.Geometries
{
    [DebuggerDisplay("Min {Min} Max {Max}")]
    internal class Envelope : XmlElementBase, IEnvelope, IEvaluationValue, IBoundable, IQuadObject
    {
        public Envelope() : this(XmlDocumentBase.Empty)
        {
        }

        public Envelope(XmlDocument document, ICoordinate min, ICoordinate max) : this(document)
        {
            Init(min, max);
        }

        public Envelope(XmlDocument document) : base(string.Empty, Constants.Xml.Box, Constants.Xml.NamespaceURI, document)
        {
        }

        public IGeometryFactory Factory
        {
            get { return OwnerDocument.Factory; }
        }

        public Envelope(ICoordinate c1, ICoordinate c2) : this(XmlDocumentBase.Empty)
        {
            Init(c1, c2);
        }

        public Envelope(double x1, double x2, double y1, double y2) : this(XmlDocumentBase.Empty)
        {
            Init(x1, x2, y1, y2);
        }

        public ICoordinate Min
        {
            get;
            protected set;
        }

        public ICoordinate Max
        {
            get;
            protected set;
        }

        public new bool IsEmpty()
        {
            return Min == null || Max == null || Min.IsEmpty() || Max.IsEmpty();
        }

        public void SetNull()
        {
            if (IsEmpty())
            {
                Min = Coordinate.Empty;
                Max = Coordinate.Empty;
            }
            else
            {
                Min.SetNull();
                Max.SetNull();
            }
        }

        public void BeginInit()
        {
        }

        public void EndInit()
        {
        }

        public void Init(Envelope e)
        {
            Init(e.Min, e.Max);
        }

        public void Init(ICoordinate p0, ICoordinate p1)
        {
            if (p0.Dimension > 2 || p1.Dimension > 2)
            {
                Init(p0.X, p1.X, p0.Y, p1.Y, p0.Z, p1.Z);
            }
            else
            {
                Init(p0.X, p1.X, p0.Y, p1.Y);
            }
        }

        public void Init(double[] values)
        {
            Init(values[0], values[1], values[2], values[3]);
        }

        public void Init(double x1, double x2, double y1, double y2)
        {
            Min = new Coordinate(Math.Min(x1, x2), Math.Min(y1, y2));
            Max = new Coordinate(Math.Max(x1, x2), Math.Max(y1, y2));

            Validate();
        }

        public void Init(double x1, double x2, double y1, double y2, double z1, double z2)
        {
            Min = new Coordinate(Math.Min(x1, x2), Math.Min(y1, y2), Math.Min(z1, z2));
            Max = new Coordinate(Math.Max(x1, x2), Math.Max(y1, y2), Math.Max(z1, z2));

            Validate();
        }

        protected void Validate()
        {
            if ((Min.X - Max.X).IsZero())
            {
                Min.X -= 1e-8;
                Max.X += 1e-8;
            }

            if ((Min.Y - Max.Y).IsZero())
            {
                Min.Y -= 1e-8;
                Max.Y += 1e-8;
            }
        }

        public double GetArea()
        {
            return GetWidth() * GetHeight();
        }

        public double GetWidth()
        {
            return IsEmpty() ? 0.0 : Max.X - Min.X;
        }

        public double GetHeight()
        {
            return IsEmpty() ? 0.0 : Max.Y - Min.Y;
        }

        public double GetCenterX()
        {
            return (Min.X + Max.X) / 2.0;
        }

        public double GetCenterY()
        {
            return (Min.Y + Max.Y) / 2.0;
        }

        public ICoordinate GetCenter()
        {
            if (IsEmpty())
            {
                return default;
            }

            if (Min.Dimension > 2 && Max.Dimension > 2)
            {
                return new Coordinate(GetCenterX(), GetCenterY(), (Min.Z + Max.Z) / 2.0);
            }

            return new Coordinate(GetCenterX(), GetCenterY());
        }

        public double Distance(IEnvelope other)
        {
            if (!Intersects(other))
            {
                double dx = 0.0;
                double dy = 0.0;

                if (Max.X < other.Min.X)
                {
                    dx = other.Min.X - Max.X;
                }

                if (Min.X > other.Max.X)
                {
                    dx = Min.X - other.Max.X;
                }

                if (Max.Y < other.Min.Y)
                {
                    dy = other.Min.Y - Max.Y;
                }

                if (Min.Y > other.Max.Y)
                {
                    dy = Min.Y - other.Max.Y;
                }

                if (dx.IsZero())
                {
                    return dy;
                }

                if (dy.IsZero())
                {
                    return dx;
                }

                return Math.Sqrt(dx * dx + dy * dy);
            }

            return 0.0;
        }

        public bool Intersects(ICoordinate c)
        {
            return Intersects(c.X, c.Y);
        }

        public bool Intersects(double x, double y)
        {
            if (x > Max.X || x < Min.X || y > Max.Y || y < Min.Y)
            {
                return false;
            }

            return true;
        }

        public bool Intersects(ICoordinate p0, ICoordinate p1)
        {
            var e = new Envelope(OwnerDocument);
            e.Init(p0, p1);
            return Intersects(e);
        }

        public bool Intersects(IEnvelope other)
        {
            if (other == null || other.IsEmpty())
            {
                return true;
            }

            if (IsEmpty())
            {
                return false;
            }

            return Max.X >= other.Min.X && Min.X <= other.Max.X && Max.Y >= other.Min.Y && Min.Y <= other.Max.Y;
        }

        public void Inflate(double x, double y)
        {
            Min.X -= x;
            Max.X += x;
            Min.Y -= y;
            Max.Y += y;
        }

        public void ExpandToInclude(ICoordinate c)
        {
            if (c.HasValue() && !c.IsEmpty())
            {
                if (IsEmpty())
                {
                    Min.SetValues(c.X, c.Y);
                    Max.SetValues(c.X, c.Y);
                }
                else
                {
                    if (Min.X > c.X) Min.X = c.X;
                    if (Min.Y > c.Y) Min.Y = c.Y;
                    if (Max.X < c.X) Max.X = c.X;
                    if (Max.Y < c.Y) Max.Y = c.Y;
                }
            }
        }

        public void ExpandToInclude(IEnvelope other)
        {
            if (other.HasValue() && other.IsEmpty() == false)
            {
                if (IsEmpty())
                {
                    (Min ?? (Min = new Coordinate())).SetValues(other.Min.X, other.Min.Y, other.Min.Z);
                    (Max ?? (Max = new Coordinate())).SetValues(other.Max.X, other.Max.Y, other.Max.Z);
                }
                else
                {
                    if (Min.X > other.Min.X) Min.X = other.Min.X;
                    if (Min.Y > other.Min.Y) Min.Y = other.Min.Y;
                    if (Max.X < other.Max.X) Max.X = other.Max.X;
                    if (Max.Y < other.Max.Y) Max.Y = other.Max.Y;
                    if (Max.Z < other.Max.Z) Max.Z = other.Max.Z;
                    if (Max.Z < other.Max.Z) Max.Z = other.Max.Z;
                }
            }
        }

        public IEnvelope ExpandedBy(IEnvelope other)
        {
            if (other.IsEmpty())
            {
                return this;
            }

            if (IsEmpty())
            {
                return other;
            }

            var e = new Envelope(OwnerDocument);

            e.Min.SetValues(other.Min.X < Min.X ? other.Min.X : Min.X, other.Min.Y < Min.Y ? other.Min.Y : Min.Y);
            e.Max.SetValues(other.Max.X > Max.X ? other.Max.X : Max.X, other.Max.Y > Max.Y ? other.Max.Y : Max.Y);

            return e;
        }

        public IEnvelope Union(IEnvelope other)
        {
            if (other == null || other.IsEmpty())
            {
                return this;
            }

            if (IsEmpty())
            {
                return other;
            }

            var e = new Envelope(OwnerDocument);

            e.ExpandToInclude(this);
            e.ExpandToInclude(other);

            return e;
        }

        public bool Contains(ICoordinate c)
        {
            return Contains(c.X, c.Y);
        }

        public bool Contains(double x, double y)
        {
            return x >= Min.X && x <= Max.X && y >= Min.Y && y <= Max.Y;
        }

        public bool Contains(IEnvelope other)
        {
            if (IsEmpty() || other == null || other.IsEmpty())
            {
                return false;
            }

            return other.Min.X >= Min.X && other.Max.X <= Max.X && other.Min.Y >= Min.Y && other.Max.Y <= Max.Y;
        }

        public static bool Intersects(ICoordinate c1, ICoordinate c2, ICoordinate q)
        {
            if (((q.X >= (c1.X < c2.X ? c1.X : c2.X)) && (q.X <= (c1.X > c2.X ? c1.X : c2.X))) && ((q.Y >= (c1.Y < c2.Y ? c1.Y : c2.Y)) && (q.Y <= (c1.Y > c2.Y ? c1.Y : c2.Y))))
            {
                return true;
            }

            return false;
        }

        public static bool Intersects(ICoordinate p0, ICoordinate p1, ICoordinate q0, ICoordinate q2)
        {
            if (Math.Min(p0.X, p1.X) > Math.Max(q0.X, q2.X))
            {
                return false;
            }

            if (Math.Max(p0.X, p1.X) < Math.Max(p0.X, p1.X))
            {
                return false;
            }

            if (Math.Min(p0.Y, p1.Y) > Math.Max(q0.Y, q2.Y))
            {
                return false;
            }

            if (Math.Max(p0.Y, p1.Y) < Math.Min(q0.Y, q2.Y))
            {
                return false;
            }

            return true;
        }

        public IEnvelope Zoom(double percent)
        {
            return Zoom(percent, percent);
        }

        public IEnvelope Zoom(double percentX, double percentY)
        {
            if (IsEmpty())
            {
                return this;
            }

            ICoordinate c = GetCenter();

            double w = (GetWidth() * percentX / 100.0);
            double h = (GetHeight() * percentY / 100.0);

            var e = new Envelope(OwnerDocument);
            e.Init(c.X - w / 2, c.X + w / 2, c.Y - h / 2, c.Y + h / 2, Min.Z, Max.Z);
            return e;
        }

        public IEnvelope Normalize(int width, int height)
        {
            if (IsEmpty() || width == 0 || height == 0)
            {
                return this;
            }

            ICoordinate center = GetCenter();

            if (center.HasValue())
            {
                var zoom = GetWidth();
                var e = new Envelope(OwnerDocument);
                var mapHeight = (zoom * height) / width;

                e.Init(center.X - zoom * .5, center.X + zoom * .5, center.Y - mapHeight * .5, center.Y + mapHeight * .5, Min.Z, Max.Z);

                if (e.GetHeight() < GetHeight())
                {
                    zoom *= GetHeight() / e.GetHeight();
                    mapHeight = (zoom * height) / width;
                    e.Init(center.X - zoom * .5, center.X + zoom * .5, center.Y - mapHeight * .5, center.Y + mapHeight * .5, Min.Z, Max.Z);
                }

                return e;
            }

            return this;
        }

        public IPolygon ToPolygon()
        {
            IEnvelope e = this;

            if (IsEmpty())
            {
                return default;
            }

            var poly = Factory.Create<IPolygon>();
            poly.Coordinates.Add(e.Cast<Coordinate>());
            poly.Coordinates.IsClosed = true;
            return poly;
        }

        public IEnumerable<ILineSegment> GetSegments()
        {
            var segment = new LineSegment();
            var coords = this.Cast<Coordinate>().ToArray();

            for (int n = 0; n < 3; n++)
            {
                segment.P0 = coords[n];
                segment.P1 = coords[n + 1];

                yield return segment;
            }

            segment.P0 = coords[3];
            segment.P1 = coords[0];

            yield return segment;
        }

        public IEnvelope Transform(IMathTransform transform)
        {
            if (transform.HasValue())
            {
                IGeometry g = ToPolygon();
                g = g.Transform(transform);
                return g.GetBounds();
            }

            return this;
        }

        public void LoadXml(XmlNode node)
        {
            XmlElement e = node["envelope"];

            if (e == null)
            {
                return;
            }

            Min.LoadXml(e[Constants.Xml.LowerCorner]);
            Max.LoadXml(e[Constants.Xml.UpperCorner]);
        }

        public void SaveXml(XmlNode node)
        {
            XmlElement min = node[Constants.Xml.LowerCorner] ?? node.OwnerDocument.CreateElement(Constants.Xml.LowerCorner);
            XmlElement max = node[Constants.Xml.UpperCorner] ?? node.OwnerDocument.CreateElement(Constants.Xml.UpperCorner);

            Min.SaveXml(min);
            Max.SaveXml(max);

            node.AppendChild(min);
            node.AppendChild(max);
        }

        public Type LoadValue(ILGenerator e)
        {
            MethodInfo createEnvelope = typeof(GeometryFactory).GetMethod("CreateEnvelope", BindingFlags.Public | BindingFlags.Static, Types.Double, Types.Double, Types.Double, Types.Double);

            e.Emit(OpCodes.Ldc_R8, Min.X);
            e.Emit(OpCodes.Ldc_R8, Max.X);
            e.Emit(OpCodes.Ldc_R8, Min.Y);
            e.Emit(OpCodes.Ldc_R8, Max.Y);
            e.Emit(OpCodes.Call, createEnvelope);

            return typeof(IEnvelope);
        }

        public override string ToString()
        {
            if (IsEmpty())
            {
                return default;
            }

            return string.Concat(Min.X.ToText(), ",", Max.X.ToText(), ",", Min.Y.ToText(), ",", Max.Y.ToText());
        }

        public int CompareTo(IEnvelope other)
        {
            return GetCenter().CompareTo(other.GetCenter());
        }

        public new IEnvelope Clone()
        {
            return (IEnvelope)MemberwiseClone();
        }

        IEnvelope IBoundable.GetBounds()
        {
            return this;
        }

        public RectangleF GetBounds()
        {
            if (IsEmpty())
            {
                return RectangleF.Empty;
            }

            return RectangleF.FromLTRB((float)Min.X, (float)Min.Y, (float)Max.X, (float)Max.Y);
        }

        public static IGeometry Read(ITokenEnumerator e)
        {
            if (e.MoveNext() && e.Current.Equals('('))
            {
                var NextDouble = new Func<double>(() =>
                {
                    while (e.MoveNext())
                    {
                        if (e.Current is NumberToken)
                        {
                            return Convert.ToDouble(e.Current.Value);
                        }
                    }

                    return 0.0;
                });

                return new Envelope(NextDouble(), NextDouble(), NextDouble(), NextDouble()).ToPolygon();
            }

            return default;
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public new IEnumerator<ICoordinate> GetEnumerator()
        {
            yield return new Coordinate(Min.X, Min.Y, Max.Z);
            yield return new Coordinate(Max.X, Min.Y, Max.Z);
            yield return new Coordinate(Max.X, Max.Y, Max.Z);
            yield return new Coordinate(Min.X, Max.Y, Max.Z);
        }

        public bool Equals(IEnvelope other)
        {
            if (other == null)
            {
                return false;
            }

            if (IsEmpty())
            {
                return other.IsEmpty();
            }

            return Min.IsEquivalent(other.Min) && Max.IsEquivalent(other.Max);
        }
    }
}
