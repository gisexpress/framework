//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.CoordinateSystems;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Geometries.Algorithm;
using System.Geometries.Operation.Buffer;
using System.IO;
using System.Linq;
using System.Xml;

namespace System.Geometries
{
    internal class Arc : Ellipse, IArc
    {
        //public Arc()
        //{
        //}

        //public Arc(BinaryReader reader)
        //{
        //    var p0 = new Coordinate(reader);
        //    var p2 = new Coordinate(reader);
        //    var p1 = new Coordinate(reader);

        //    Build(p0, p1, p2);
        //}

        public Arc(XmlDocument doc) : base(Constants.Xml.Arc, doc)
        {
        }

        public bool Build(ICoordinate p0, ICoordinate p1, ICoordinate p2)
        {
            return Build(p0, p1, p2, default(ILineSegment), default(ILineSegment));
        }

        public bool Build(ICoordinate p0, ICoordinate p1, ICoordinate p2, ILineSegment segment0, ILineSegment segment1)
        {
            ICoordinate center;

            segment0 = segment0 ?? new LineSegment(p0.X, p0.Y, p1.X, p1.Y);
            segment1 = segment1 ?? new LineSegment(p1.X, p1.Y, p2.X, p2.Y);

            segment0.Rotate(90);
            segment1.Rotate(90);

            center = HCoordinate.Intersection(segment0.P0, segment0.P1, segment1.P0, segment1.P1);

            if (center.HasValue())
            {
                double startAngle, endAngle, sweepAngle;
                double radius = p0.Distance(center);

                sweepAngle = OffsetCurveBuilder.GetAngle(center, p0, p1, -LineSegment.ComputeOrientation(p0, p1, p2), out startAngle, out endAngle);

                if (IsEmpty())
                {
                    Coordinates.Add(center.X - radius, center.Y + radius);
                    Coordinates.Add(center.X + radius, center.Y - radius);
                }
                else
                {
                    Coordinates.Get(0).SetValues(center.X - radius, center.Y + radius);
                    Coordinates.Get(1).SetValues(center.X + radius, center.Y - radius);
                }

                StartAngle = startAngle;
                SweepAngle = sweepAngle;

                return true;
            }

            return false;
        }

        public override string TypeName
        {
            get { return "CIRCULARSTRING"; }
        }

        public override double GetArea()
        {
            return 0.0;
        }

        public override double GetLength()
        {
            if (NumPoints() > 1)
            {
                if (SweepAngle.IsZero())
                {
                    return StartPoint.Distance(EndPoint);
                }

                return SweepAngle.Abs() * (((Width / 2.0).Pow() + (Height / 2.0).Pow()) / 2.0).Sqrt();
            }

            return 0.0;
        }

        public override double GetAngle()
        {
            return SweepAngle;
        }

        public double StartAngle
        {
            get;
            set;
        }

        public double SweepAngle
        {
            get;
            set;
        }

        public override IApplicationComponent GetComponent(IApplicationComponentDesigner designer)
        {
            return new ArcComponent(designer, this);
        }

        protected override IGeometry OnTransform(IMathTransform transform)
        {
            IArc arc;
            IGeometry g = base.OnTransform(transform);

            if ((arc = g as IArc).HasValue())
            {
                arc.StartAngle = StartAngle;
                arc.SweepAngle = SweepAngle;

                return arc;
            }

            return g;
        }

        public override void AppendToPath(Graphics g, GraphicsPath path, Func<ICoordinate, PointF> transform, bool raiseEvents)
        {
            if (NumPoints() > 0)
            {
                base.AppendToPath(g, path, transform, false);

                if (raiseEvents && path.PointCount > 0)
                {
                    if (PointVisitorSettings.Current.EndPoint)
                    {
                        foreach (ICoordinate c in GetEditableCoordinates(default(IApplicationComponent)))
                        {
                            if (PointVisitorSettings.Current.EndPoint)
                            {
                                Coordinate.InvokeVisited(c, transform);
                            }
                        }
                    }

                    if (PointVisitorSettings.Current.Center)
                    {
                        Coordinate.InvokeVisited(GetCentroid(), transform, false, true);
                    }
                }
            }
        }

        protected override void OnAppendToPath(Graphics g, GraphicsPath path, Func<ICoordinate, PointF> transform, float x, float y, float width, float height)
        {
            if (StartAngle.IsZero() && SweepAngle.IsZero())
            {
                path.AddLine(transform(StartPoint), transform(EndPoint));
            }
            else
            {
                if (width >= 4F && height >= 4F)
                {
                    var sweepAngle = (float)SweepAngle.RadianToDegree();

                    if (sweepAngle.Abs() >= 2F)
                    {
                        path.AddArc(x, y, width, height, -(float)StartAngle.RadianToDegree(), -sweepAngle);
                    }
                }
            }
        }

        public override IEnvelope GetBounds()
        {
            IGeometry g = AsGeometry();

            if (g.HasValue())
            {
                return g.GetBounds();
            }

            return default;
        }

        protected override IGeometry OnConvertToGeometry()
        {
            ICoordinate[] coords = GetCentroid().GetFilletPoints(Width / 2.0, Height / 2.0, StartAngle, StartAngle + SweepAngle, BufferParameters.QuadrantSegments).ToArray();

            if (coords.Length > 0)
            {
                return Factory.Create<ILineString>(coords);
            }

            return default;
        }

        public override IEnumerable<ICoordinate> GetEditableCoordinates(IApplicationComponent component)
        {
            var c = GetCentroid();

            double w = Width / 2.0;
            double h = Height / 2.0;

            if (component.IsNull())
            {
                yield return c.GetPointAt(w, h, StartAngle);
                yield return c.GetPointAt(w, h, (StartAngle + StartAngle + SweepAngle) / 2.0);
                yield return c.GetPointAt(w, h, StartAngle + SweepAngle);
            }
            else
            {
                yield return c.GetPointAt(w, h, StartAngle);
                yield return c.GetPointAt(w, h, StartAngle + SweepAngle);
                yield return c.GetPointAt(w, h, (StartAngle + StartAngle + SweepAngle) / 2.0);
            }
        }

        public override object GetValue(GeometryProperty property)
        {
            switch (property)
            {
                case GeometryProperty.StartAngle:
                    return StartAngle;
                case GeometryProperty.SweepAngle:
                    return SweepAngle;
            }

            return base.GetValue(property);
        }

        public override void SetValue(GeometryProperty property, object value)
        {
            switch (property)
            {
                case GeometryProperty.StartAngle:
                    StartAngle = ((double)value).DegreeToRadian();
                    break;
                case GeometryProperty.SweepAngle:
                    SweepAngle = ((double)value).DegreeToRadian();
                    break;
            }

            base.SetValue(property, value);
        }

        public override IEnumerable<ILineSegment> GetSegments()
        {
            return AsGeometry().GetSegments();
        }

        public override IEnumerable<PropertyDescriptor> GetProperties(IApplicationComponent component)
        {
            var readOnly = new ReadOnlyAttribute(component.IsBusy());

            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.StartAngle, readOnly);
            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.SweepAngle, readOnly);
            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Length, new ReadOnlyAttribute(!(component.IsDetached() && NumPoints() == 2)));
        }

        protected override IGeometry OnClone()
        {
            var arc = base.OnClone() as IArc;

            arc.StartAngle = StartAngle;
            arc.SweepAngle = SweepAngle;

            return arc;
        }

        public override string ToString()
        {
            if (IsEmpty())
            {
                return "(Empty)";
            }
            
            return string.Concat(TypeName, '(', GetEditableCoordinates(default(IApplicationComponent)).Select(c => c.ToString()).Join(", "), ')');
        }
    }
}
