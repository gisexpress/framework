//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.ComponentModel;
using System.IO;

namespace System.Geometries
{
    internal class GeometrySerializer : IBinarySerializer
    {
        public static IGeometry Read(BinaryReader reader)
        {
            var shape = default(IGeometry);
            //var order = (WkbByteOrder)reader.ReadByte();

            //if (order == WkbByteOrder.LittleEndian)
            //{
            //    var shapeType = (GeometryType)reader.ReadInt32();

            //    switch (shapeType)
            //    {
            //        case GeometryType.Point:
            //            shape = new Point(reader);
            //            break;
            //        case GeometryType.LineString:
            //            shape = new LineString(reader);
            //            break;
            //        case GeometryType.CircularString:
            //            shape = ReadCircularString(reader);
            //            break;
            //        case GeometryType.Polygon:
            //            shape = new Polygon(reader, reader.ReadInt32(), reader.ReadInt32());
            //            break;
            //        case GeometryType.MultiPoint:
            //            shape = new MultiPoint(reader);
            //            break;
            //        case GeometryType.MultiLineString:
            //            shape = new MultiLineString(reader);
            //            break;
            //        case GeometryType.MultiPolygon:
            //            shape = new MultiPolygon(reader);
            //            break;
            //        case GeometryType.GeometryCollection:
            //            shape = new GeometryCollection(reader);
            //            break;
            //    }

            //    if (shape.HasValue())
            //    {
            //        if (shape.IsEmpty)
            //        {
            //            return default(IGeometry);
            //        }

            //        if (shapeType == GeometryType.Polygon)
            //        {
            //            if (((IPolygon)shape).IsRectangle)
            //            {
            //                var r = new Rectangle();

            //                r.Coordinates.Add(shape.Coordinates.Get(0));
            //                r.Coordinates.Add(shape.Coordinates.Get(2));

            //                return r;
            //            }
            //        }
            //    }
            //}

            return shape;
        }

        //static IGeometry ReadCircularString(BinaryReader reader)
        //{
        //    int numPoints = reader.ReadInt32();

        //    if (numPoints == 3)
        //    {
        //        return new Arc(reader);
        //    }

        //    return default(IGeometry);
        //}

        object IBinarySerializer.Read(BinaryReader reader)
        {
            return Read(reader);
        }

        void IBinarySerializer.Write(BinaryWriter writer, object value)
        {
            ((IGeometry)value).Write(writer);
        }
    }
}
