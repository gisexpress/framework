//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.CoordinateSystems;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Xml;

namespace System.Geometries
{
    internal class Circle : Rectangle, ICircle
    {
        public Circle(XmlDocument doc) : base(Constants.Xml.Circle, doc)
        {
        }

        public Circle(string localName, XmlDocument doc) : base(localName, doc)
        {
        }

        public override string TypeName
        {
            get { return "Circle"; }
        }

        public double Radius
        {
            get { return Width / 2.0; }
            set
            {
                ICoordinate center = GetCentroid();
                StartPoint.SetValues(center.X - value, center.Y - value);
                EndPoint.SetValues(center.X + value, center.Y + value);
            }
        }

        public override double GetArea()
        {
            return Math.PI * Radius.Pow();
        }

        public override double GetLength()
        {
            return Math.PI * Width;
        }

        public override IApplicationComponent GetComponent(IApplicationComponentDesigner designer)
        {
            return new CircleComponent(designer, this);
        }

        protected override void OnAppendToPath(Graphics g, GraphicsPath path, Func<ICoordinate, PointF> transform, float x, float y, float width, float height)
        {
            path.AddEllipse(x, y, width, height);
        }

        protected override void OnDrawPath(Graphics g, GraphicsPath path, PaintStyle style)
        {
            g.TryDrawPath(style.LineStyle.GetPen(), path);
        }

        protected override void OnFillPath(Graphics g, GraphicsPath path, PaintStyle style)
        {
        }

        protected override IGeometry OnTransform(IMathTransform transform)
        {
            ICircle g = Factory.Create<ICircle>();

            var center = GetCentroid();
            var p1 = new Coordinate(StartPoint.X + Radius, StartPoint.Y);
            var p2 = new Coordinate(StartPoint.X + Radius, EndPoint.Y);

            transform.Transform(p1);
            transform.Transform(p2);
            transform.Transform(center);

            double r = p1.Distance(p2) / 2.0;

            g.Coordinates.Add(center.X - r, center.Y - r);
            g.Coordinates.Add(center.X + r, center.Y + r);

            return g;
        }

        protected override IGeometry OnConvertToGeometry()
        {
            var g = Factory.Create<IPoint>(GetCentroid());
            g.BufferParameters = BufferParameters;
            return g.Buffer(Radius);
        }

        public override IEnumerable<ICoordinate> GetEditableCoordinates(IApplicationComponent component)
        {
            IEnumerator<ICoordinate> e = GetCoordinates().GetEnumerator();

            if (e.MoveNext())
            {
                ICoordinate c = e.Current;

                while (e.MoveNext())
                {
                    yield return LineSegment.GetMidPoint(c, e.Current);
                    c = e.Current;
                }

                if (component.HasValue() && !component.IsDetached())
                {
                    yield return GetCentroid();
                }
            }
        }

        public override object GetValue(GeometryProperty property)
        {
            switch (property)
            {
                case GeometryProperty.Radius:
                    return Radius;
            }

            return base.GetValue(property);
        }

        public override void SetValue(GeometryProperty property, object value)
        {
            switch (property)
            {
                case GeometryProperty.Radius:
                    Radius = (double)value;
                    break;
            }

            base.SetValue(property, value);
        }

        public override IEnumerable<ILineSegment> GetSegments()
        {
            return AsGeometry().GetSegments();
        }

        public override IEnumerable<PropertyDescriptor> GetProperties(IApplicationComponent component)
        {
            var readOnly = new ReadOnlyAttribute(true);

            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Area, readOnly);
            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Perimeter, readOnly);
            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Radius, new ReadOnlyAttribute(NumPoints() != 2));
        }
    }
}
