//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.CoordinateSystems;
using System.Xml;

namespace System.Geometries
{
    internal class Ellipse : Circle, IEllipse
    {
        public Ellipse(XmlDocument doc) : base(Constants.Xml.Ellipse, doc)
        {
        }

        public Ellipse(string localName, XmlDocument doc) : base(localName, doc)
        {
        }

        public override string TypeName
        {
            get { return "Ellipse"; }
        }

        public override double GetArea()
        {
            if (NumPoints() > 1)
            {
                return (Math.PI * Width * Height) / 4.0;
            }

            return 0.0;
        }

        public override double GetLength()
        {
            if (NumPoints() > 1)
            {
                return AppConstants.TwoPI * (((Width / 2.0).Pow() + (Height / 2.0).Pow()) / 2.0).Sqrt();
            }

            return 0.0;
        }

        public override IApplicationComponent GetComponent(IApplicationComponentDesigner designer)
        {
            return new EllipseComponent(designer, this);
        }

        protected override IGeometry OnTransform(IMathTransform transform)
        {
            IGeometry g = Factory.Create<IPolygon>(GetCoordinates()).Transform(transform);

            if (g.HasValue() && (g as IPolygon).IsRectangle())
            {
                var rect = Activator.CreateInstance(GetType()) as IRectangle;
                var p0 = StartPoint.Clone();
                var p1 = EndPoint.Clone();

                transform.Transform(p0);
                transform.Transform(p1);

                rect.Coordinates.Add(p0);
                rect.Coordinates.Add(p1);

                return rect;
            }

            g = AsGeometry();

            if (g.HasValue())
            {
                return g.Transform(transform);
            }

            return default(IGeometry);
        }

        protected override IGeometry OnConvertToGeometry()
        {
            throw new NotImplementedException();
            //var g = new Point(GetCentroid());
            //g.BufferParameters = BufferParameters;
            //return g.Buffer(Width / 2.0, Height / 2.0);
        }

        //public override IGeometry3D AsGeometry3D(IMapTransform transform)
        //{
        //    return base.AsGeometry3D(transform);
        //}

        public override IEnumerable<ILineSegment> GetSegments()
        {
            return AsGeometry().GetSegments();
        }

        public override IEnumerable<PropertyDescriptor> GetProperties(IApplicationComponent component)
        {
            var readOnly = new ReadOnlyAttribute(true);
            var readOnly2 = new ReadOnlyAttribute(NumPoints() != 2 || (component.IsBusy() && !component.IsDetached()));

            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Area, readOnly);
            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Perimeter, readOnly);
            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Width, readOnly2);
            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Height, readOnly2);
        }
    }
}
