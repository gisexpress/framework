//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.CoordinateSystems;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Geometries.Algorithm;
using System.Geometries.Operation.Relate;
using System.IO;
using System.Linq;
using System.Xml;

namespace System.Geometries
{
    internal class GeometryCollection : GeometryCollection<IGeometry>
    {
        public GeometryCollection(XmlDocument document) : base(Constants.Xml.GeometryCollection, document)
        {
        }

        public void Add(IEnumerable<IGeometry> items)
        {
            foreach (IGeometry g in items)
            {
                Add(g);
            }
        }

        protected override IGeometry OnClone()
        {
            var c = base.OnClone() as GeometryCollection;

            foreach (IGeometry item in Geometries)
            {
                c.Geometries.Add(item.Clone());
            }

            return c;
        }
    }

    internal class GeometryCollection<T> : Geometry, IGeometryCollection where T : IGeometry
    {
        public GeometryCollection(string localName, XmlDocument document) : base(localName, document)
        {
            Geometries = new GeometryItemCollection<T>(this);
        }

        public override bool IsEmpty()
        {
            return Geometries.Count == 0;
        }

        public override int NumGeometries()
        {
            return Geometries.Count;
        }

        public override IGeometry GetGeometryN(int i)
        {
            return Geometries[i];
        }

        public Collection<T> Geometries
        {
            get;
            protected set;
        }

        public virtual GeometryType ItemType
        {
            get { return GeometryType.Geometry; }
        }

        public override string TypeName
        {
            get { return "GeometryCollection"; }
        }

        public override bool IsCollection()
        {
            return true;
        }

        public void Add(IGeometry geometry)
        {
            var item = (T)geometry;

            if (!Geometries.Contains(item))
            {
                Geometries.Add(item);
            }
        }

        public void AddRange(IEnumerable<IGeometry> geometries)
        {
            foreach (T item in geometries.Cast<T>())
            {
                Geometries.Add(item);
            }
        }

        public override IEnumerable<ILineSegment> GetSegments()
        {
            foreach (IGeometry g in GetGeometries())
            {
                foreach (ILineSegment segment in g.GetSegments())
                {
                    yield return segment;
                }
            }
        }

        public override IEnumerable<IGeometry> GetGeometries()
        {
            foreach (T g in Geometries)
            {
                yield return g;
            }
        }

        public override IEnumerable<ICoordinate> GetCoordinates()
        {
            foreach (T g in Geometries)
            {
                foreach (Coordinate c in g.GetCoordinates())
                {
                    yield return c;
                }
            }
        }

        public override Dimensions GetDimension()
        {
            return Geometries.Aggregate(Dimensions.False, (current, g) => (Dimensions)Math.Max((int)current, (int)g.GetDimension()));
        }

        public override Dimensions GetBoundaryDimension()
        {
            return Geometries.Aggregate(Dimensions.False, (current, g) => (Dimensions)Math.Max((int)current, (int)g.GetBoundaryDimension()));
        }

        public override double GetLength()
        {
            return Geometries.Sum(g => g.GetLength());
        }

        public override double GetArea()
        {
            return Geometries.Sum(g => g.GetArea());
        }

        public override double GetDistance(ICoordinate c)
        {
            throw new NotImplementedException();
        }

        public override double GetDistance(IGeometry other)
        {
            throw new NotImplementedException();
        }

        public override ICoordinate GetCentroid()
        {
            double x = 0.0;
            double y = 0.0;
            int numCentroids = 0;

            foreach (T g in Geometries)
            {
                ICoordinate c = g.GetCentroid();

                x += c.X;
                y += c.Y;

                numCentroids++;
            }

            return new Coordinate(x / numCentroids, y / numCentroids);
        }

        public override IEnvelope GetBounds()
        {
            var bounds = Factory.Create<IEnvelope>();

            foreach (T g in Geometries)
            {
                bounds.ExpandToInclude(g.GetBounds());
            }

            return bounds;
        }

        public override bool Contains(ICoordinate c)
        {
            foreach (T g in Geometries)
            {
                if (g.Contains(c))
                {
                    return true;
                }
            }

            return false;
        }

        public override bool Contains(IEnvelope e)
        {
            throw new NotImplementedException();
        }

        public override IGeometry MakeValid()
        {
            if (NumGeometries() == 1)
            {
                return Geometries.First();
            }

            if (ItemType == GeometryType.Geometry)
            {
                IGeometryCollection c;
                IEnumerable<IGeometry> e = GetGeometries();

                if (e.All(item => item.TypeName.Equals(Constants.Xml.Point)))
                {
                    c = Factory.Create<IMultiPoint>();
                    c.AddRange(e);
                    return c;
                }
                else if (e.All(item => item.TypeName.Equals(Constants.Xml.LineString)))
                {
                    c = Factory.Create<IMultiLineString>();
                    c.AddRange(e);
                    return c;
                }
                else if (e.All(item => item.TypeName.Equals(Constants.Xml.Polygon)))
                {
                    c = Factory.Create<IMultiPolygon>();
                    c.AddRange(e);
                    return c;
                }
            }

            return base.MakeValid();
        }

        public override bool IsEquivalent(IGeometry other)
        {
            var collectionOther = other as GeometryCollection<T>;

            if (collectionOther.HasValue() && Geometries.Count == collectionOther.Geometries.Count)
            {
                return Geometries.IsEquivalent(collectionOther.Geometries, g => g.GetHashCode(), ArrayComparison.Disorderly);
            }

            return false;
        }

        public override Locations Locate(ICoordinate c)
        {
            int numBoundaries = 0;
            bool interior = false;

            foreach (IGeometry g in this)
            {
                Locations location = g.Locate(c);

                if (location == Locations.Interior) interior = true;
                if (location == Locations.Boundary) numBoundaries++;
            }

            if (BoundaryNodeRules.Mod2BoundaryRule.IsInBoundary(numBoundaries))
            {
                return Locations.Boundary;
            }

            if (interior || numBoundaries > 0)
            {
                return Locations.Interior;
            }

            return Locations.Exterior;
        }

        protected override bool OnRelate(IGeometry g0, IGeometry g1, RelateOperations operation)
        {
            IGeometry self = g0 == this ? g0 : g1;

            for (int n = 0; n < NumGeometries(); n++)
            {
                if (base.OnRelate(self, GetGeometryN(n), operation))
                {
                    return true;
                }
            }

            return false;
        }

        protected override IGeometry OnTransform(IMathTransform transform)
        {
            throw new NotImplementedException();

            //var g = new GeometryCollection<T>();

            //foreach (T item in Geometries)
            //{
            //    var current = (T)item.Transform(transform);

            //    if (current.HasValue())
            //    {
            //        g.Geometries.Add(current);
            //    }
            //}

            //return g;
        }

        public override bool Read(ITokenEnumerator e)
        {
            if (e.ReadNext('('))
            {
                while (true)
                {
                    IGeometry g;

                    if (ItemType == GeometryType.Geometry)
                    {
                        g = ReadInternal(e);
                    }
                    else
                    {
                        g = (T)Factory.Create(string.Concat('I', Enums.GetName(ItemType)));

                        if (g.Read(e) == false)
                        {
                            return false;
                        }
                    }

                    Geometries.Add((T)g);

                    if (e.ReadNext(')'))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        protected override void OnWrite(BinaryWriter writer)
        {
            writer.Write((byte)WkbByteOrder.LittleEndian);
            writer.Write((int)GeometryType.GeometryCollection);
            writer.Write(NumGeometries());

            foreach (T g in GetGeometries())
            {
                g.Write(writer);
            }
        }

        public override void AppendToPath(Graphics g, GraphicsPath path, Func<ICoordinate, PointF> transform, bool raiseEvents)
        {
            foreach (T item in Geometries)
            {
                path.StartFigure();
                item.AppendToPath(g, path, transform, raiseEvents);
            }
        }

        public override IEnumerable<PropertyDescriptor> GetProperties(IApplicationComponent component)
        {
            var readOnly = new ReadOnlyAttribute(true);

            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Area, readOnly);
            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Length, readOnly);
            //yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.NumPoints, readOnly);
        }

        //protected override void ClearItems()
        //{
        //    Geometries.Clear();
        //    base.ClearItems();
        //}

        public new IEnumerator<IGeometry> GetEnumerator()
        {
            return Geometries.Cast<IGeometry>().GetEnumerator();
        }

        protected override IGeometry OnClone()
        {
            var c = base.OnClone() as GeometryCollection<T>;

            foreach (IGeometry item in Geometries)
            {
                c.Geometries.Add((T)item.Clone());
            }

            return c;
        }

        public override bool IsEquivalent(ICoordinateCollection other, int compareAt, ArrayComparison comparisonType)
        {
            var otherGeometries = other as IGeometryCollection;

            if (otherGeometries.HasValue())
            {
                return Geometries.Cast<IGeometry>().ToList().IsEquivalent(otherGeometries.Cast<IGeometry>().ToList(), GetHashCode, compareAt, comparisonType);
            }

            return false;
        }

        public override int GetHashCode()
        {
            return Hash.Get(GetGeometries());
        }

        public override string ToString()
        {
            return string.Concat(TypeName.ToUpperInvariant(), '(', Geometries.Select(g => g.ToString()).Join(","), ')');
        }
    }
}