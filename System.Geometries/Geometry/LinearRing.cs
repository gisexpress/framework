//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Geometries.Algorithm;
using System.Xml;

namespace System.Geometries
{
    internal class LinearRing : LineString, ILinearRing, IKeyedObject
    {
        public const int MinimumValidSize = 4;

        //public LinearRing() : base()
        //{
        //}

        public LinearRing(XmlDocument document) : base(Constants.Xml.LinearRing, document)
        {
        }

        public LinearRing(string localName, XmlDocument document) : base(localName, document)
        {
        }

        //public LinearRing(ICoordinate[] coordinates)
        //    : base(coordinates)
        //{
        //}

        //public LinearRing(BinaryReader reader)
        //    : base(reader, reader.ReadInt32())
        //{
        //}

        //public LinearRing(BinaryReader reader, int numPoints)
        //    : base(reader, numPoints)
        //{
        //}

        public override bool IsRing()
        {
            return true;
        }

        public override void Normalize(bool clockwise)
        {
            Scroll(GetPointMin());

            if (IsClockwise() != clockwise)
            {
                Reverse();
            }
        }

        public override double GetAngle()
        {
            return 0.0;
        }

        public override double GetLength()
        {
            double value = base.GetLength();

            if (IsClosed())
            {
                return value;
            }

            value += StartPoint.Distance(EndPoint);
            return value;
        }

        public override IEnumerable<ILineSegment> GetSegments(ICoordinate c)
        {
            int n = NumPoints() > 2 ? Coordinates.IndexOf(c) : -1;

            foreach (ILineSegment segment in base.GetSegments(c))
            {
                yield return segment;

                if (n == 0)
                {
                    yield return new LineSegment(c, Coordinates.Get(NumPoints() - 1)); break;
                }
                else if (n == NumPoints() - 1)
                {
                    yield return new LineSegment(c, Coordinates.Get(0)); break;
                }
            }
        }

        public override bool Contains(ICoordinate c)
        {
            if (c.HasValue() && c.IsEmpty() == false)
            {
                int n = 0;
                int length = NumPoints();

                for (int i = 1; i < length; i++)
                {
                    int index = i - 1;
                    ICoordinate c1 = Coordinates.Get(i);
                    ICoordinate c2 = Coordinates.Get(index);

                    double y1 = c1.Y - c.Y;
                    double y2 = c2.Y - c.Y;

                    if (((y1 > 0.0) && (y2 <= 0.0)) || ((y2 > 0.0) && (y1 <= 0.0)))
                    {
                        if (0.0 < RobustDeterminant.OrientationIndex(c1, c2, c) / (y2 - y1))
                        {
                            n++;
                        }
                    }
                }

                return (n % 2) == 1;
            }

            return false;
        }

        public override IGeometry MakeValid()
        {
            Coordinates.IsClosed = true;
            return this;
        }

        public override Locations Locate(ICoordinate c)
        {
            if (IsOnLine(c, 1e-14))
            {
                return Locations.Boundary;
            }

            if (Contains(c))
            {
                return Locations.Interior;
            }

            return Locations.Exterior;
        }

        public override void AppendToPath(Graphics g, GraphicsPath path, Func<ICoordinate, PointF> transform, bool raiseEvents)
        {
            base.AppendToPath(g, path, transform, raiseEvents);

            if (NumPoints() > 2)
            {
                path.CloseFigure();
            }
        }

        protected override void OnDrawPath(Graphics g, GraphicsPath path, PaintStyle style)
        {
            if (style.PolyStyle.Outline)
            {
                g.TryDrawPath(style.LineStyle.GetPen(), path);
            }
        }

        protected override void OnFillPath(Graphics g, GraphicsPath path, PaintStyle style)
        {
            if (style.PolyStyle.Fill)
            {
                g.TryFillPath(style.PolyStyle.GetBrush(), path);
            }
        }

        public override IEnumerable<PropertyDescriptor> GetProperties(IApplicationComponent component)
        {
            var readOnly = new ReadOnlyAttribute(true);

            if (!component.IsBusy())
            {
                yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Altitude);
            }

            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Area, readOnly);
            yield return GeometryFactory.CreatePropertyDescriptor(component, GeometryProperty.Length, readOnly);
        }

        public override bool IsEquivalent(IGeometry other)
        {
            if (other is LinearRing)
            {
                return Coordinates.IsEquivalent(other.Coordinates, 1, ArrayComparison.Disorderly);
            }

            return false;
        }

        public override bool IsEquivalent(ICoordinateCollection other, int compareAt, ArrayComparison comparisonType)
        {
            if (comparisonType == ArrayComparison.Sequential)
            {
                return base.IsEquivalent(other, compareAt, comparisonType);
            }

            return base.IsEquivalent(other, 1, comparisonType);
        }

        public override IEnumerable<ICoordinate> GetCoordinates()
        {
            foreach (ICoordinate c in base.GetCoordinates())
            {
                yield return c;
            }

            if (!IsClosed())
            {
                yield return StartPoint;
            }
        }

        public override int GetHashCode()
        {
            return Hash.Get(TypeName.ToLowerInvariant(), Coordinates.GetHashCode());
        }
    }
}
