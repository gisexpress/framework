//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Geometries.Index;
using System.Geometries.Index.Quadtree;
using System.Geometries.Operation.Polygonize;
using System.Linq;
using System.Xml;

namespace System.Geometries
{
    public class GeometryFactory : TypeFactory, IGeometryFactory
    {
        public static new readonly IGeometryFactory Default;

        static GeometryFactory()
        {
            Default = new GeometryFactory(XmlDocumentBase.Empty);
            TypeFactory.Default.Register<IGeometryFactory, GeometryFactory>();
        }

        public GeometryFactory(XmlDocumentBase document)
        {
            Document = document;

            Register<IPoint, Point>();
            Register<ILineString, LineString>();
            Register<ILinearRing, LinearRing>();
            Register<IPolygon, Polygon>();
            Register<IRectangle, Rectangle>();
            Register<IEllipse, Ellipse>();
            Register<ICircle, Circle>();
            Register<IArc, Arc>();
            Register<IMultiPoint, MultiPoint>();
            Register<IMultiLineString, MultiLineString>();
            Register<IMultiPolygon, MultiPolygon>();
            Register<IGeometryCollection, GeometryCollection>();
            Register<ICoordinate, Coordinate>();
            Register<ICoordinateCollection, CoordinateCollection>();
            Register<ILinearRingCollection, LinearRingCollection>();
            Register<IEnvelope, Envelope>();
            Register<ILineSegment, LineSegment>();
            Register<IPolygonizer, Polygonizer>();
            Register<IMapTransform, MapTransform>();
            Register<ISpatialIndex<SnapObject>, Quadtree<SnapObject>>();

            TypeDescriptor.AddAttributes(typeof(IGeometry), new TypeConverterAttribute(typeof(GeometryTypeConverter)));
        }

        readonly XmlDocumentBase Document;

        public static void Register()
        {
            // This method exists to call static constructor
        }

        public event PointVisitedEventHandler PointVisited
        {
            add { Coordinate.PointVisited += value; }
            remove { Coordinate.PointVisited -= value; }
        }

        public readonly Type ShapeType = typeof(Geometry);

        public double NorthAngle
        {
            get;
            set;
        }

        public MeasuringSystems MeasuringSystem
        {
            get;
            set;
        }

        public static IGeometry Read(string wellKnownText)
        {
            return Geometry.Read(wellKnownText);
        }

        protected override object OnCreateInstance(Type componentType)
        {
            if (Types.XmlElementBase.IsAssignableFrom(componentType))
            {
                return Activator.CreateInstance(componentType, Document);
            }

            return base.OnCreateInstance(componentType);
        }

        protected override object OnCreateInstance(Type componentType, IList<object> args)
        {
            if (Types.XmlElementBase.IsAssignableFrom(componentType))
            {
                args.Insert(0, Document);
            }

            return base.OnCreateInstance(componentType, args);
        }

        //public ILinearRing CreateLinearRing(ICoordinate c1, ICoordinate c2)
        //{
        //    var bounds = new Envelope(c1, c2);
        //    ILinearRing g = Create<ILinearRing>(document);

        //    g.Coordinates.Add(bounds.Min.X, bounds.Min.Y);
        //    g.Coordinates.Add(bounds.Min.X, bounds.Max.Y);
        //    g.Coordinates.Add(bounds.Max.X, bounds.Max.Y);
        //    g.Coordinates.Add(bounds.Max.X, bounds.Min.Y);
        //    g.Coordinates.Add(bounds.Min.X, bounds.Min.Y);

        //    return g;
        //}

        //public ILinearRing CreateLinearRing(XmlDocument document, IEnumerable<ICoordinate> coordinates)
        //{
        //    ILinearRing g = Create<ILinearRing>(document);

        //    g.Coordinates.Add(coordinates);
        //    g.Coordinates.IsClosed = true;

        //    return g;
        //}

        public IGeometry BuildGeometry(IEnumerable<IGeometry> geometries)
        {
            if (geometries is null)
            {
                throw new ArgumentNullException(nameof(geometries));
            }

            geometries = geometries.RemoveNullElements().ToArray();
            geometries = geometries.Select(g => g.AsGeometry()).ToArray();
            geometries = geometries.SelectMany(g => g.GetGeometries()).ToArray().RemoveNullElements().ToArray();

            if (geometries.Count() > 1)
            {
                var collection = default(IGeometryCollection);

                if (geometries.GroupBy(g => g.TypeName).Count() == 1)
                {
                    switch (geometries.First().TypeName)
                    {
                        case Constants.Xml.Point:
                            collection = Create<IMultiPoint>();
                            break;

                        case Constants.Xml.LineString:
                            collection = Create<IMultiLineString>();
                            break;

                        case Constants.Xml.Polygon:
                            collection = Create<IMultiPolygon>();
                            break;

                        default:
                            collection = Create<IGeometryCollection>();
                            break;
                    }

                    collection.AddRange(geometries);
                    return collection;
                }

                collection = Create<IGeometryCollection>();
                collection.AddRange(geometries);
                return collection;
            }

            return geometries.FirstOrDefault();
        }

        public double GetAzimuth(ICoordinate point, ICoordinate other)
        {
            return GetAzimuth(point, other, MeasuringSystem, NorthAngle);
        }

        public double GetAzimuth(ICoordinate point, ICoordinate other, MeasuringSystems measuring, double north)
        {
            double azimuth = 0.0;

            double dx = point.X - other.X;
            double dy = point.Y - other.Y;
            double d = dy / dx;

            if (!double.IsInfinity(d))
            {
                if (dx > 0.0)
                {
                    azimuth = 90.0 - Math.Atan(d).RadianToDegree();
                }
                else if (dx < 0.0)
                {
                    azimuth = 270.0 - Math.Atan(d).RadianToDegree();
                }
            }
            else if (dy < 0.0)
            {
                azimuth = 180.0;
            }

            azimuth -= north;

            if (measuring == MeasuringSystems.SouthAzimuth || measuring == MeasuringSystems.SolarAzimuth)
            {
                azimuth = (azimuth + 180) % 360;
            }

            if (measuring == MeasuringSystems.SolarAzimuth)
            {
                azimuth = (azimuth - Math.Sign(azimuth - 180) * 360) % 360;
            }

            return azimuth;
        }

        public static PropertyDescriptor CreatePropertyDescriptor(IApplicationComponent component, GeometryProperty property, params Attribute[] attributes)
        {
            return new GeometryPropertyDescriptor(component, property, attributes);
        }
    }
}
