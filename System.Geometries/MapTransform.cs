//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.CoordinateSystems;
using System.Drawing;
using System.Transformations;
using System.Windows.Forms;
using SystemPoint = System.Drawing.Point;

namespace System.Geometries
{
    internal class MapTransform : IMapTransform
    {
        public static readonly int ActualScreenWidth;
        public static readonly float ActualMonitorWidth;

        static MapTransform()
        {
            ActualScreenWidth = SystemInformation.PrimaryMonitorSize.Width;

            using (var c = new Control())
            {
                using (Graphics g = c.CreateGraphics())
                {
                    ActualMonitorWidth = ActualScreenWidth / g.DpiX * 2.54f;
                }
            }
        }

        public MapTransform()
            : this(default)
        {
        }

        public MapTransform(Func<IEnvelope> boundsGet)
        {
            GetBounds = boundsGet;
        }

        protected bool Empty;
        protected ICoordinate Center;
        protected double ZoomFactor;
        //protected IAxisTransform Axis = Matrix3D.Identity;
        protected MatrixTransform Matrix = new MatrixTransform();

        public bool IsEmpty()
        {
            return Empty;
        }

        public event Action ScaleChanged;

        public IUnit Unit
        {
            get;
            set;
        }

        public Func<IEnvelope> GetBounds
        {
            get;
            protected set;
        }

        public IEnvelope Bounds
        {
            get;
            protected set;
        }

        public int ClientWidth
        {
            get;
            set;
        }

        public int ClientHeight
        {
            get;
            set;
        }

        public ICoordinate ClientToWorld(SystemPoint point)
        {
            if (ClientToWorld(point.X, point.Y, out double worldX, out double worldY))
            {
                return new Coordinate(worldX, worldY);
            }

            return default;
        }

        public ICoordinate ClientToWorld(PointF point)
        {
            if (ClientToWorld(point.X, point.Y, out double worldX, out double worldY))
            {
                return new Coordinate(worldX, worldY);
            }

            return default;
        }

        public IEnvelope ClientToWorld(RectangleF rect)
        {
            IEnvelope e = Bounds.Factory.Create<IEnvelope>();

            ClientToWorld(rect.Left, rect.Top, out double minx, out double miny);
            ClientToWorld(rect.Right, rect.Bottom, out double maxx, out double maxy);

            e.Init(minx, maxx, miny, maxy);

            return e;
        }

        public bool ClientToWorld(int x, int y, out double worldX, out double worldY)
        {
            return ClientToWorld((float)x, y, out worldX, out worldY);
        }

        public bool ClientToWorld(float x, float y, out double worldX, out double worldY)
        {
            if (IsEmpty())
            {
                worldX = 0.0;
                worldY = 0.0;
                return false;
            }

            worldX = Bounds.Min.X + x * PixelSize;
            worldY = Bounds.Max.Y - y * PixelSize;

            return Matrix.Transform(ref worldX, ref worldY);
        }

        public PointF WorldToClient(ICoordinate point)
        {
            return WorldToClient(point.X, point.Y);
        }

        public PointF WorldToClient(double x, double y)
        {
            if (WorldToClient(x, y, out float clientX, out float clientY))
            {
                return new PointF(clientX, clientY);
            }

            return PointF.Empty;
        }

        public bool WorldToClient(double x, double y, out int clientX, out int clientY)
        {
            if (WorldToClient(x, y, out float fx, out float fy))
            {
                clientX = fx.Round();
                clientY = fy.Round();
                return true;
            }
            else
            {
                clientX = 0;
                clientY = 0;
                return false;
            }
        }

        public bool WorldToClient(double x, double y, out float clientX, out float clientY)
        {
            if (IsEmpty())
            {
                clientX = 0;
                clientY = 0;
                return false;
            }

            double h = (ZoomFactor * ClientHeight) / ClientWidth;
            double left = Center.X - ZoomFactor * .5;
            double top = Center.Y + h * .5;

            clientX = (float)((x - left) / PixelSize);
            clientY = (float)((top - y) / PixelSize);
            return true;
        }

        public RectangleF WorldToClient(IEnvelope bounds)
        {
            PointF min = WorldToClient(bounds.Min);
            PointF max = WorldToClient(bounds.Max);

            return new RectangleF(min.X, max.Y, max.X - min.X, min.Y - max.Y);
        }

        public double PixelSize
        {
            get { return ZoomFactor / ClientWidth; }
        }

        public double DiagonalSize
        {
            get { return PixelSize * (ClientWidth.Pow() + ClientHeight.Pow()).Sqrt(); }
        }

        public double HorizontalResolution
        {
            get { return ToMeter(PixelSize); }
        }

        public double MapHeight
        {
            get { return (ZoomFactor * ClientHeight) / ClientWidth; }
        }

        public bool Normalize()
        {
            return NormalizeInternal();
        }

        public bool ZoomToExtent()
        {
            return ZoomToExtentInternal();
        }

        bool ZoomToExtentInternal()
        {
            var bounds = GetBounds.InvokeSafely() as IEnvelope;

            if (bounds.IsEmpty())
            {
                bounds.Init(-10, 10, -10, 10);
            }
            else
            {
                bounds = bounds.Zoom(120);
            }

            //if (!Axis.AxisIsIdentity)
            //{
            //    bounds = bounds.Transform(Axis);
            //}

            return ZoomTo(bounds);
        }

        public bool Zoom(int percent)
        {
            return ZoomInternal(percent);
        }

        bool ZoomInternal(int percent)
        {
            if (IsEmpty())
            {
                return false;
            }

            ZoomFactor *= percent / 100F;
            Bounds.Init(Center.X - ZoomFactor * .5, Center.X + ZoomFactor * .5, Center.Y - MapHeight * .5, Center.Y + MapHeight * .5, Bounds.Min.Z, Bounds.Max.Z);
            RaiseScaleChanged();

            return true;
        }

        public bool ZoomAt(int percent, PointF point)
        {
            return ZoomAtInternal(percent, point);
        }

        bool ZoomAtInternal(int percent, PointF point)
        {
            if (IsEmpty())
            {
                return false;
            }

            ClientToWorld(point.X, point.Y, out double x1, out double y1);

            if (Zoom(percent))
            {
                ClientToWorld(point.X, point.Y, out double x2, out double y2);
                SetCenter(Center.X + x1 - x2, Center.Y + y1 - y2);

                return true;
            }

            return false;
        }

        public bool ZoomTo(RectangleF rect)
        {
            return ZoomToInternal(ClientToWorld(rect));
        }

        public bool ZoomTo(IEnvelope bounds)
        {
            return ZoomToInternal(bounds);
        }

        bool ZoomToInternal(IEnvelope bounds)
        {
            if (bounds == null || bounds.IsEmpty())
            {
                return false;
            }

            IEnvelope boundsNew = bounds.Normalize(ClientWidth, ClientHeight);

            if (boundsNew.IsEmpty())
            {
                return false;
            }

            float width = (float)boundsNew.GetWidth();

            Bounds = boundsNew;
            Center = Bounds.GetCenter();
            ZoomFactor = width;
            Empty = Bounds == null || Bounds.IsEmpty() || Center == null;
            RaiseScaleChanged();

            return true;
        }

        public void Translate(PointF p1, PointF p2)
        {
            TranslateInternal(p1.X, p1.Y, p2.X, p2.Y);
        }

        public void Translate(float x1, float y1, float x2, float y2)
        {
            TranslateInternal(x1, y1, x2, y2);
        }

        public void RotateAt(double angle, double x, double y)
        {
            Matrix.RotateAt(angle, x, y);
        }

        public void Resize(int width, int height)
        {
            if (ClientWidth > 0 && ClientHeight > 0)
            {
                float dx = ClientWidth - width;
                float dy = ClientHeight - height;

                Translate(0F, 0F, dx / 2F, dy / 2F);
                ZoomFactor = PixelSize * width;
                ClientWidth = width;
                ClientHeight = height;
                SetCenter(Center.X, Center.Y);
            }

            ClientWidth = width;
            ClientHeight = height;

            if (Bounds.IsNull())
            {
                ZoomToExtentInternal();
            }

            RaiseScaleChanged();
        }

        void TranslateInternal(float x1, float y1, float x2, float y2)
        {
            if (IsEmpty())
            {
                return;
            }

            ClientToWorld(x1, y1, out double wx1, out double wy1);
            ClientToWorld(x2, y2, out double wx2, out double wy2);

            SetCenter(Center.X + (wx1 - wx2), Center.Y + (wy1 - wy2));
        }

        public void SetCenter(ICoordinate point)
        {
            SetCenter(point.X, point.Y);
        }

        public void SetCenter(double x, double y)
        {
            if (IsEmpty())
            {
                return;
            }

            Bounds.Init(x - ZoomFactor * .5, x + ZoomFactor * .5, y - MapHeight * .5, y + MapHeight * .5, Bounds.Min.Z, Bounds.Max.Z);
            Center = Bounds.GetCenter();
        }

        public double CurrentScale
        {
            get { return CurrentScaleInternal(); }
        }

        public void RaiseScaleChanged()
        {
            ScaleChanged.InvokeSafely();
        }

        bool NormalizeInternal()
        {
            return ZoomTo(Bounds);
        }

        double CurrentScaleInternal()
        {
            if (Bounds.IsNull() || Bounds.IsEmpty())
            {
                return 0.0;
            }

            return ToMeter(Bounds.GetWidth()) / ((ActualMonitorWidth / 100.0) * ((double)ClientWidth / ActualScreenWidth));
        }

        double ToMeter(double value)
        {
            return Unit.HasValue() ? Unit.ToMeter(value) : value;
        }

        //#region AxisTransform

        //int IMathTransform.GetSrid()
        //{
        //    return Axis.GetSrid();
        //}

        //bool IMathTransform.Invert()
        //{
        //    return Axis.Invert();
        //}

        //bool IMathTransform.Transform(ICoordinate point)
        //{
        //    Axis.Transform(point);
        //    return true;
        //}

        //bool IAxisTransform.AxisIsIdentity
        //{
        //    get { return Axis.AxisIsIdentity; }
        //}

        //void IAxisTransform.ResetAxis()
        //{
        //    Axis.ResetAxis();
        //}

        //void IAxisTransform.RotateAxis(double x, double y, double z)
        //{
        //    Axis.RotateAxis(x, y, z);
        //}

        //void IAxisTransform.RotateAxisAt(double x, double y, double z, ICoordinate center)
        //{
        //    Axis.RotateAxisAt(x, y, z, center);
        //}

        //#endregion

        public virtual object Clone()
        {
            var c = (MapTransform)MemberwiseClone();

            c.Bounds = Bounds.Clone();
            c.Center = Center.Clone();
            c.ScaleChanged = null;

            return c;
        }

        public void Dispose()
        {
            Unit = null;
            Bounds = null;
            Center = null;
            ScaleChanged = null;
            Empty = true;
            GC.SuppressFinalize(this);
        }
    }
}
