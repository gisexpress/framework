//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2017. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace System.Runtime
{
    [Obfuscation(Exclude = true)]
    public abstract class ExpressionFunction : ExpressionOperator, IExpressionFunction, IValueOperand
    {
        protected static readonly Dictionary<string, IExpressionFunction> Functions;
        protected IValueOperand ValueOperand;

        static ExpressionFunction()
        {
            Functions = new Dictionary<string, IExpressionFunction>(StringComparer.InvariantCultureIgnoreCase);
            Register<InOperator>();
            Register<BeetweenOperator>();
            Register<MathFunction>();
            Register<DateTimeFunction>();
            Register<SelectOperator>();
            Register<InsertOperator>();
            Register<UpdateOperator>();
            Register<DeleteOperator>();
            Register<WhereOperator>();
            Register<GroupOperator>();
            Register<OrderOperator>();
            Register<IsOperator>();
            Register<AggregateFunction>();
            //Register<CreateOperator>();
            Register<AlterOperator>();
            //Register<DropOperator>();
            Register<DeclareOperator>();
        }

        public static void Register<T>() where T : IExpressionFunction
        {
            IExpressionFunctionCollection functions;
            IExpressionFunction function = Activator.CreateInstance<T>();

            if ((functions = function as IExpressionFunctionCollection).IsNull())
            {
                Register(function);
            }
            else
            {
                foreach (string name in functions.GetFunctionNames().Distinct())
                {
                    Register(Activator.CreateInstance(typeof(T), name) as IExpressionFunction);
                }
            }
        }

        static void Register(IExpressionFunction item)
        {
            if (Functions.ContainsKey(item.GetFunctionName()))
            {
                Functions[item.GetFunctionName()] = item;
            }
            else
            {
                Functions.Add(item.GetFunctionName(), item);
            }
        }

        internal static bool TryParseOperator(ITokenEnumerator e, IExpressionOperatorCollection operands, out IExpressionOperator o)
        {
            IExpressionFunction function;

            if (Functions.TryGetValue(e.Current.StringValue, out function))
            {
                var name = function.GetFunctionName();
                var leftOperand = operands.LastOrDefault();
                var binaryOperand = leftOperand as IBinaryOperator;

                if (function.HasLeftOperand())
                {
                    if (leftOperand == null || !leftOperand.Remove())
                    {
                        throw new ExpressionParserException("Incorrect syntax near the keyword '{0}'.".FormatInvariant(name), e.Current.Line, e.Current.Position - e.Current.LegacyToString().Length);
                    }
                }

                e.MoveNext();

                if (function.TryParse(e, binaryOperand.HasValue() ? binaryOperand.RightOperand : leftOperand, out function))
                {
                    if (binaryOperand.HasValue())
                    {
                        binaryOperand.RightOperand = function;
                        o = binaryOperand;
                    }
                    else
                    {
                        o = function;
                    }

                    return true;
                }

                throw new ExpressionParserException("Incorrect syntax near the keyword '{0}'".FormatInvariant(name), e.Current.Line, e.Current.Position - e.Current.LegacyToString().Length);
            }

            o = default(IExpressionOperator);
            return false;
        }

        public abstract string GetFunctionName();

        public virtual bool HasLeftOperand()
        {
            return true;
        }

        public abstract bool TryParse(ITokenEnumerator e, IExpressionOperator leftOperand, out IExpressionFunction result);

        #region IValueOperand

        bool IValueOperand.SupportsArguments
        {
            get { return ValueOperand.HasValue(); }
        }

        Type IValueOperand.ReturnType
        {
            get { return ValueOperand.ReturnType; }
        }

        Quotes IValueOperand.Quote
        {
            get { return Quotes.None; }
            set { }
        }

        void IValueOperand.Add(string name)
        {
            ValueOperand.Add(name);
        }

        void IValueOperand.AddWithArgument(string name, IExpressionOperator arg)
        {
            ValueOperand.AddWithArgument(name, arg);
        }

        void IValueOperand.AddWithArguments(string name, IExpressionOperatorCollection args)
        {
            ValueOperand.AddWithArguments(name, args);
        }

        IList<IExpressionOperatorCollection> IValueOperand.Arguments
        {
            get { return ValueOperand.Arguments; }
        }

        object IValueOperand.Value
        {
            get { return GetValue(); }
            set { throw new NotSupportedException(); }
        }

        protected virtual object GetValue()
        {
            return default(object);
        }

        #endregion
    }
}
