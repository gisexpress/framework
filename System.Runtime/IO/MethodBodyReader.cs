//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;

namespace System.Runtime.IO
{
    public class MethodBodyReader
    {
        public MethodBodyReader(MethodInfo method)
        {
            Method = method;

            if (method.HasValue())
            {
                MethodBody body = method.GetMethodBody();

                if (body.HasValue())
                {
                    Il = body.GetILAsByteArray();
                    ConstructInstructions(method.Module);
                }
            }
        }

        protected byte[] Il;
        protected readonly MethodInfo Method;

        public List<IlInstruction> Instructions;

        ushort ReadUInt16(ref int position)
        {
            return (ushort)((Il[position++] | (Il[position++] << 8)));
        }

        int ReadInt32(ref int position)
        {
            return (((Il[position++] | (Il[position++] << 8)) | (Il[position++] << 0x10)) | (Il[position++] << 0x18));
        }

        ulong ReadInt64(ref int position)
        {
            return (ulong)(((Il[position++] | (Il[position++] << 8)) | (Il[position++] << 0x10)) | (Il[position++] << 0x18) | (Il[position++] << 0x20) | (Il[position++] << 0x28) | (Il[position++] << 0x30) | (Il[position++] << 0x38));
        }

        double ReadDouble(ref int position)
        {
            return (((Il[position++] | (Il[position++] << 8)) | (Il[position++] << 0x10)) | (Il[position++] << 0x18) | (Il[position++] << 0x20) | (Il[position++] << 0x28) | (Il[position++] << 0x30) | (Il[position++] << 0x38));
        }

        sbyte ReadSByte(ref int position)
        {
            return (sbyte)Il[position++];
        }

        byte ReadByte(ref int position)
        {
            return Il[position++];
        }

        Single ReadSingle(ref int position)
        {
            return ((Il[position++] | (Il[position++] << 8)) | (Il[position++] << 0x10)) | (Il[position++] << 0x18);
        }

        void ConstructInstructions(Module module)
        {
            byte[] il = Il;
            int position = 0;
            Instructions = new List<IlInstruction>();

            while (position < il.Length)
            {
                OpCode code;
                ushort value = il[position++];
                var instruction = new IlInstruction();

                if (value != 0xfe)
                {
                    code = Globals.SingleByteOpCodes[value];
                }
                else
                {
                    value = il[position++];
                    code = Globals.MultiByteOpCodes[value];
                }

                instruction.Code = code;
                instruction.Offset = position - 1;
                int metadataToken;

                switch (code.OperandType)
                {
                    case OperandType.InlineBrTarget:
                        metadataToken = ReadInt32(ref position);
                        metadataToken += position;
                        instruction.Operand = metadataToken;
                        break;
                    case OperandType.InlineField:
                        metadataToken = ReadInt32(ref position);
                        instruction.Operand = module.ResolveField(metadataToken);
                        break;
                    case OperandType.InlineMethod:
                        metadataToken = ReadInt32(ref position);
                        try
                        {
                            instruction.Operand = module.ResolveMethod(metadataToken);
                        }
                        catch
                        {
                            instruction.Operand = module.ResolveMember(metadataToken);
                        }
                        break;
                    case OperandType.InlineSig:
                        metadataToken = ReadInt32(ref position);
                        instruction.Operand = module.ResolveSignature(metadataToken);
                        break;
                    case OperandType.InlineTok:
                        metadataToken = ReadInt32(ref position);
                        try { instruction.Operand = module.ResolveType(metadataToken); }
                        catch { }
                        break;
                    case OperandType.InlineType:
                        metadataToken = ReadInt32(ref position);
                        var declaringType = Method.DeclaringType;
                        if (!ReferenceEquals(declaringType, null)) instruction.Operand = module.ResolveType(metadataToken, declaringType.GetGenericArguments(), Method.GetGenericArguments());
                        break;
                    case OperandType.InlineI:
                        {
                            instruction.Operand = ReadInt32(ref position);
                            break;
                        }
                    case OperandType.InlineI8:
                        {
                            instruction.Operand = ReadInt64(ref position);
                            break;
                        }
                    case OperandType.InlineNone:
                        {
                            instruction.Operand = null;
                            break;
                        }
                    case OperandType.InlineR:
                        {
                            instruction.Operand = ReadDouble(ref position);
                            break;
                        }
                    case OperandType.InlineString:
                        {
                            metadataToken = ReadInt32(ref position);
                            instruction.Operand = module.ResolveString(metadataToken);
                            break;
                        }
                    case OperandType.InlineSwitch:
                        {
                            int count = ReadInt32(ref position);
                            var casesAddresses = new int[count];
                            for (int i = 0; i < count; i++)
                            {
                                casesAddresses[i] = ReadInt32(ref position);
                            }
                            var cases = new int[count];
                            for (int i = 0; i < count; i++)
                            {
                                cases[i] = position + casesAddresses[i];
                            }
                            break;
                        }
                    case OperandType.InlineVar:
                        {
                            instruction.Operand = ReadUInt16(ref position);
                            break;
                        }
                    case OperandType.ShortInlineBrTarget:
                        {
                            instruction.Operand = ReadSByte(ref position) + position;
                            break;
                        }
                    case OperandType.ShortInlineI:
                        {
                            instruction.Operand = ReadSByte(ref position);
                            break;
                        }
                    case OperandType.ShortInlineR:
                        {
                            instruction.Operand = ReadSingle(ref position);
                            break;
                        }
                    case OperandType.ShortInlineVar:
                        {
                            instruction.Operand = ReadByte(ref position);
                            break;
                        }
                    default:
                        {
                            throw new Exception("Unknown operand type.");
                        }
                }

                Instructions.Add(instruction);
            }
        }

        public object GetRefferencedOperand(Module module, int metadataToken)
        {
            AssemblyName[] assemblyNames = module.Assembly.GetReferencedAssemblies();

            foreach (AssemblyName name in assemblyNames)
            {
                Module[] modules = Assembly.Load(name).GetModules();

                foreach (Module m in modules)
                {
                    try
                    {
                        Type t = m.ResolveType(metadataToken);
                        return t;
                    }
                    catch { }
                }
            }

            return null;
        }

        public string GetBodyCode()
        {
            var result = default(string);

            if (Instructions.HasValue())
            {
                foreach (IlInstruction ili in Instructions)
                {
                    result = string.Concat(result, ili.GetCode(), Environment.NewLine);
                }
            }

            return result;
        }
    }
}
