//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2017. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;

namespace System.Runtime
{
    public class ExpressionInstructionEventArgs : IInstructionEventArgs
    {
        public ExpressionInstructionEventArgs(ExpressionOperator o)
        {
            Operator = o;
        }

        protected static readonly ConstructorInfo DateTimeConstructor = Types.DateTime.GetConstructor(new[] { Types.Int64, Types.EnumDateTimeKind });
        protected static readonly ConstructorInfo DecimalConstructor = Types.Decimal.GetConstructor(new[] { Types.Int32, Types.Int32, Types.Int32, Types.Boolean, Types.Byte });

        protected bool SupportsProperty;
        protected bool SupportsInstructions;

        protected ISupportProperty PropertySupport;
        protected ISupportInstructions InstructionsSupport;

        protected readonly ExpressionOperator Operator;

        public object Component
        {
            get;
            protected set;
        }

        public bool ComponentIsNull
        {
            get;
            protected set;
        }

        public Type ComponentType
        {
            get;
            protected set;
        }

        public IExpressionOperator Operand
        {
            get;
            set;
        }

        public ILGenerator Generator
        {
            get;
            protected set;
        }

        public Func<object> CreateDelegate(out Type returnType)
        {
            return CreateDelegate(default(object), default(Type), Types.FuncObj, out returnType) as Func<object>;
        }

        public Func<object, object> CreateDelegate(object component, out Type returnType)
        {
            Debug.Assert(component.HasValue());
            return CreateDelegate(component, component.GetType(), Types.FuncObjObj, out returnType) as Func<object, object>;
        }

        public Func<object, object> CreateDelegate(Type componentType, out Type returnType)
        {
            return CreateDelegate(default(object), componentType, Types.FuncObjObj, out returnType) as Func<object, object>;
        }

        public object CreateDelegate(object component, Type componentType, Type delegateType, out Type returnType)
        {
            if (Operator.IsEmpty() || Operator.IsHandled())
            {
                Debug.Fail("Operator is empty or already handled");
                returnType = default(Type);
                return default(object);
            }

            DynamicMethod method = NewDynamicMethod(component, componentType);

            Generator = method.GetILGenerator();
            Generator.Emit(OpCodes.Nop);
            Generator.Emit(OpCodes.Box, returnType = Operator.PutInstructions(this));
            Generator.Emit(OpCodes.Ret);

            return method.CreateDelegate(delegateType);
        }

        DynamicMethod NewDynamicMethod(object component, Type componentType)
        {
            Component = component;
            ComponentIsNull = (ComponentType = componentType).IsNull();

            PropertySupport = Component as ISupportProperty;
            InstructionsSupport = Component as ISupportInstructions;

            SupportsProperty = PropertySupport.HasValue();
            SupportsInstructions = InstructionsSupport.HasValue();

            return new DynamicMethod("Eval", Types.Object, ComponentIsNull ? Types.TypeArrayEmpty : Types.TypeArrayObject, (ComponentType ?? GetType()).Module, true);
        }

        public void Not()
        {
            Generator.Emit(OpCodes.Ldc_I4, 0);
            Generator.Emit(OpCodes.Ceq);
        }

        public void BitwiseNot()
        {
            Generator.Emit(OpCodes.Not);
        }

        public void Negates()
        {
            Generator.Emit(OpCodes.Neg);
        }

        public void Cast(Type valueType)
        {
            Generator.Emit(OpCodes.Unbox_Any, valueType);
        }

        public void LoadNull()
        {
            Generator.Emit(OpCodes.Ldnull);
        }

        public void LoadValue(bool value)
        {
            Generator.Emit(OpCodes.Ldc_I4, value ? 1 : 0);
        }

        public void LoadValue(int value)
        {
            Generator.Emit(OpCodes.Ldc_I4, value);
        }

        public void LoadValue(long value)
        {
            Generator.Emit(OpCodes.Ldc_I8, value);
        }

        public void LoadValue(float value)
        {
            Generator.Emit(OpCodes.Ldc_R4, value);
        }

        public void LoadValue(double value)
        {
            Generator.Emit(OpCodes.Ldc_R8, value);
        }

        public void LoadValue(decimal value)
        {
            int[] bits = decimal.GetBits(value);

            Generator.Emit(OpCodes.Ldc_I4, bits[0]);
            Generator.Emit(OpCodes.Ldc_I4, bits[1]);
            Generator.Emit(OpCodes.Ldc_I4, bits[2]);
            Generator.Emit((bits[3] & 0x80000000) == 0 ? OpCodes.Ldc_I4_0 : OpCodes.Ldc_I4_1);
            Generator.Emit(OpCodes.Ldc_I4, (bits[3] >> 16) & 0x7f);
            Generator.Emit(OpCodes.Newobj, DecimalConstructor);
        }

        public void LoadValue(string value)
        {
            Generator.Emit(OpCodes.Ldstr, value);
        }

        public void LoadValue(DateTime value)
        {
            LocalBuilder local = Generator.DeclareLocal(Types.DateTime);

            Generator.Emit(OpCodes.Ldloca, local);
            Generator.Emit(OpCodes.Ldc_I8, ((DateTime)value).Ticks);
            Generator.Emit(OpCodes.Ldc_I4, (int)((DateTime)value).Kind);
            Generator.Emit(OpCodes.Call, DateTimeConstructor);
            Generator.Emit(OpCodes.Ldloc, local);
        }

        public void LoadValue(IEvaluationValue value)
        {
            if (value.HasValue())
            {
                value.LoadValue(Generator);
            }
            else
            {
                throw new NotSupportedException();
            }
        }

        public void LoadArray(IExpressionOperatorCollection parameters)
        {
            LoadArray(parameters, Types.Object);
        }

        public void LoadArray(IExpressionOperatorCollection parameters, Type elementType)
        {
            LocalBuilder items = Generator.DeclareLocal(elementType.MakeArrayType());

            Generator.Emit(OpCodes.Ldc_I4, parameters.IsNull() ? 0 : parameters.Count);
            Generator.Emit(OpCodes.Newarr, elementType);
            Generator.Emit(OpCodes.Stloc, items);

            if (parameters.HasValue())
            {
                int n = 0;

                foreach (IExpressionOperator o in parameters)
                {
                    Generator.Emit(OpCodes.Nop);
                    Generator.Emit(OpCodes.Ldloc, items);
                    Generator.Emit(OpCodes.Ldc_I4, n++);
                    Generator.Emit(OpCodes.Box, o.PutInstructions(this));
                    Generator.Emit(OpCodes.Stelem_Ref);
                }
            }

            Generator.Emit(OpCodes.Ldloc, items);
        }

        public Type LoadValue(object value)
        {
            return LoadValue(value, value.GetType());
        }

        public Type LoadValue(object value, Type valueType)
        {
            switch (Type.GetTypeCode(valueType))
            {
                case TypeCode.Boolean:
                    LoadValue((bool)value);
                    break;

                case TypeCode.Byte:
                    LoadValue((int)(byte)value);
                    break;

                case TypeCode.Int16:
                    LoadValue((int)(short)value);
                    break;

                case TypeCode.Int32:
                    LoadValue((int)value);
                    break;

                case TypeCode.Int64:
                    LoadValue((long)value);
                    break;

                case TypeCode.Single:
                    LoadValue((float)value);
                    break;

                case TypeCode.Double:
                    LoadValue((double)value);
                    break;

                case TypeCode.Decimal:
                    LoadValue((decimal)value);
                    break;

                case TypeCode.DateTime:
                    LoadValue((DateTime)value);
                    break;

                case TypeCode.String:
                    LoadValue((string)value);
                    break;

                default:
                    LoadValue((IEvaluationValue)value);
                    break;
            }

            return valueType;
        }

        public void MakeRef(Type valueType)
        {
            if (valueType.IsValueType)
            {
                LocalBuilder local = Generator.DeclareLocal(valueType);

                Generator.Emit(OpCodes.Stloc, local);
                Generator.Emit(OpCodes.Ldloca, local);
            }
        }

        public bool TryCallMember(string name, out Type returnType)
        {
            return TryCallMember(name, out returnType, default(Func<int, IExpressionOperatorCollection>), ComponentType);
        }

        public bool TryCallMember(string name, out Type returnType, Func<int, IExpressionOperatorCollection> parameterN)
        {
            return TryCallMember(name, out returnType, parameterN, ComponentType);
        }

        public bool TryCallMember(string name, out Type returnType, Func<int, IExpressionOperatorCollection> parameterN, Type declaringType)
        {
            if (declaringType.IsNull())
            {
                if (SupportsInstructions)
                {
                    IEnumerator<string> memberNames = name.SplitWithoutEmptyEntries().GetEnumerator();

                    if (memberNames.MoveNext())
                    {
                        int n;

                        if ((n = InstructionsSupport.PutMemberInstructions(this, name, memberNames, out returnType)) > 0)
                        {
                            if (name.StartsWith("@"))
                            {
                                return true;
                            }

                            if (memberNames.MoveNext())
                            {
                                MakeRef(returnType);
                                return TryCallMembers(memberNames, out returnType, (index) => parameterN(index + n), returnType);
                            }

                            return true;
                        }
                    }
                }

                if (SupportsProperty)
                {
                    if ((returnType = PropertySupport.GetPropertyType(name)).HasValue())
                    {
                        CallPropertyIndexer(name, returnType);
                        return true;
                    }

                    if (name.Contains("."))
                    {
                        IEnumerator<string> memberNames = name.SplitWithoutEmptyEntries().GetEnumerator();

                        if (memberNames.MoveNext())
                        {
                            if (PropertySupport.ComponentName.EqualsIgnoreCase(memberNames.Current))
                            {
                                memberNames.MoveNext();
                            }

                            if ((returnType = PropertySupport.GetPropertyType(memberNames.Current)).HasValue())
                            {
                                CallPropertyIndexer(memberNames.Current, returnType);

                                if (memberNames.MoveNext())
                                {
                                    MakeRef(returnType);

                                    if (TryCallMembers(memberNames, out returnType, (index) => parameterN(index + 1), returnType))
                                    {
                                        return true;
                                    }
                                }
                                else
                                {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }

            if (!ComponentIsNull || declaringType.HasValue())
            {
                if (!ComponentIsNull && declaringType.IsNull())
                {
                    Generator.Emit(OpCodes.Nop);
                    Generator.Emit(OpCodes.Ldarg_0);
                    Generator.Emit(OpCodes.Unbox_Any, ComponentType);
                }

                using (IEnumerator<string> e = name.SplitWithoutEmptyEntries().GetEnumerator())
                {
                    if (e.MoveNext())
                    {
                        if (TryCallMembers(e, out returnType, parameterN, declaringType ?? ComponentType))
                        {
                            return true;
                        }
                    }
                }
            }

            returnType = default(Type);
            return false;
        }

        protected void CallPropertyIndexer(string memberName, Type returnType)
        {
            PropertyInfo property;

            if (MethodCache.TryGetProperty(ComponentType, memberName, out property))
            {
                Generator.Emit(OpCodes.Ldarg_0);
                Generator.Emit(OpCodes.Call, property.GetGetMethod());
                returnType = property.PropertyType;
            }
            else
            {
                Generator.Emit(OpCodes.Nop);
                Generator.Emit(OpCodes.Ldarg_0);
                Generator.Emit(OpCodes.Castclass, typeof(ISupportProperty));
                Generator.Emit(OpCodes.Ldstr, memberName);
                Generator.Emit(OpCodes.Call, MethodCache.SupportProperty.GetPropertyValue);
                Generator.Emit(OpCodes.Unbox_Any, returnType);
            }
        }

        public bool TryCallMembers(IEnumerator<string> e, out Type returnType, Func<int, IExpressionOperatorCollection> parameterN)
        {
            return TryCallMembers(e, out returnType, parameterN, ComponentType);
        }

        public bool TryCallMembers(IEnumerator<string> e, out Type returnType, Func<int, IExpressionOperatorCollection> parameterN, Type declaringType)
        {
            int n = 0;
            MethodInfo method;
            PropertyInfo property;
            returnType = declaringType;

            while (true)
            {
                Type[] parameterTypes;
                var parameters = parameterN == null ? default(IExpressionOperatorCollection) : parameterN(n++);
                bool parametersIsNull = parameters.IsNull() || parameters.Count == 0;

                if (parametersIsNull)
                {
                    if (MethodCache.TryGetMethod(returnType, e.Current, out method))
                    {
                        returnType = method.ReturnType;
                        Generator.Emit(OpCodes.Call, method);
                    }
                    else if (MethodCache.TryGetProperty(returnType, e.Current, out property))
                    {
                        returnType = property.PropertyType;
                        Generator.Emit(OpCodes.Call, property.GetGetMethod());
                    }
                }
                else
                {
                    parameterTypes = parameters.PutInstructions(this);

                    if (MethodCache.TryGetMethod(returnType, e.Current, out method, parameterTypes))
                    {
                        returnType = method.ReturnType;
                        Generator.Emit(OpCodes.Call, method);
                    }
                    else if (MethodCache.TryGetProperty(returnType, e.Current, out property))
                    {
                        returnType = property.PropertyType;
                        Generator.Emit(OpCodes.Call, property.GetGetMethod());
                    }
                    else
                    {
                        throw new MissingFieldException(returnType.Name, e.Current);
                    }
                }

                if (e.MoveNext())
                {
                    MakeRef(returnType);
                }
                else
                {
                    break;
                }
            }

            return true;
        }
    }
}
