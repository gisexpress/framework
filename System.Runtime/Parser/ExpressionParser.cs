//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2017. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Linq;
using System.Runtime;

namespace System.IO.Runtime
{
    internal class ExpressionParser : Tokenizer
    {
        protected ExpressionParser(string s)
            : base(s, true)
        {
        }

        public static new ITokenEnumerator Parse(string s)
        {
            return Parse(s, default(object));
        }

        public static ITokenEnumerator Parse(string s, object component)
        {
            var e = new ExpressionParser(s);

            e.Component = component;
            e.ReadAll();

            return e;
        }

        protected override void InsertItem(int index, Token item)
        {
            int n;

            if (item.Equals("true"))
            {
                item = new NumberToken(item.Line, item.Position, true);
            }
            else if (item.Equals("false"))
            {
                item = new NumberToken(item.Line, item.Position, false);
            }
            else if (item.Equals('#') && (n = Count) > 5 && base[n - 6].Equals('#'))
            {
                if (base[n - 4].Equals('/') && base[n - 2].Equals('/'))
                {
                    object year = base[n - 1].Value;
                    object month = base[n - 5].Value;
                    object day = base[n - 3].Value;

                    if (year is int && month is int && day is int)
                    {
                        n = n - 6;
                        base.RemoveAt(n);
                        base.RemoveAt(n);
                        base.RemoveAt(n);
                        base.RemoveAt(n);
                        base.RemoveAt(n);
                        base.RemoveAt(n);
                        base.Add(new DateTimeToken(item.Line, item.Position, (int)year, (int)month, (int)day));
                        return;
                    }
                }
            }

            base.InsertItem(index, item);
        }

        internal static IExpressionOperator Read(ITokenEnumerator e)
        {
            if (e.MoveNext())
            {
                var o = default(IExpressionOperator);
                var operands = OperandFactory.CreateOperatorCollection();

                while (e.CanRead)
                {
                    o = Read(e, operands);
                    operands.Add(o);
                }

                if (operands.Count == 1)
                {
                    o.Remove();
                    return o;
                }
            }

            return default(IExpressionOperator);
        }

        internal static IExpressionOperator Read(ITokenEnumerator e, IExpressionOperatorCollection operands)
        {
            var result = default(IExpressionOperator);

            UnaryOperatorType unaryOperatorType;
            BinaryOperatorType binaryOperatorType;

            if (e.CanRead)
            {
                if (ExpressionOperatorCollection.TryParseOperator(e, out result))
                {
                    result.IsGroup = true;
                    return result;
                }
                else if (BinaryOperator.TryParseOperator(e, out binaryOperatorType) && operands.Count > 0)
                {
                    IExpressionOperator leftOperand = operands.Last();

                    if (leftOperand.Remove())
                    {
                        return BinaryOperator.Combine(binaryOperatorType, leftOperand, Read(e, operands));
                    }
                }
                else if (UnaryOperator.TryParseOperator(e, out unaryOperatorType))
                {
                    IExpressionOperator o = Read(e, operands);

                    if (unaryOperatorType == UnaryOperatorType.Not)
                    {
                        while (e.CanRead)
                        {
                            if (o.IsNull())
                            {
                                break;
                            }

                            if (o.IsLogical())
                            {
                                break;
                            }

                            if (o.IsGroup)
                            {
                                break;
                            }

                            operands.Add(o);
                            o = Read(e, operands);
                        }

                        if (o.IsNull() || (!o.IsLogical() && !o.IsGroup))
                        {
                            if (!(o is OperandProperty))
                            {
                                throw new ExpressionParserException("An expression of non-boolean type specified in a context where a condition is expected, near '{0}'".FormatInvariant(e.Current.Value), e.Current.Line, e.Current.Position);
                            }
                        }

                        var binary = o as BinaryOperator;
                        var parent = default(BinaryOperator);

                        while (binary.HasValue())
                        {
                            if (binary.RightOperand is BinaryOperator)
                            {
                                parent = binary;
                                binary = binary.RightOperand as BinaryOperator;
                            }
                            else
                            {
                                if (parent.HasValue())
                                {
                                    parent.RightOperand = new UnaryOperator(unaryOperatorType, parent.RightOperand);
                                    return o;
                                }

                                break;
                            }
                        }
                    }

                    return new UnaryOperator(unaryOperatorType, o);
                }
                else if (e.Current is QuoteToken)
                {
                    result = new ValueOperand(e.Current.Value, ((QuoteToken)e.Current).Type);
                    e.MoveNext();
                }
                else if (e.Current is WordToken)
                {
                    var word = e.Current as WordToken;

                    if (ExpressionFunction.TryParseOperator(e, operands, out result) == false)
                    {
                        result = new OperandProperty(e.Current.StringValue, false);
                        e.MoveNext();
                    }
                }
                else if (e.Current is NumberToken || e.Current is DateTimeToken)
                {
                    result = new ValueOperand(e.Current.Value);
                    e.MoveNext();
                }

                if (result.IsNull())
                {
                    if (e.Current.Value.Equals('.'))
                    {
                        var leftOperand = operands.LastOrDefault() as IValueOperand;

                        if (leftOperand.HasValue() && leftOperand.SupportsArguments && e.MoveNext())
                        {
                            bool hasParameters = e.Current.Equals('(');

                            if (e.Current is WordToken || hasParameters)
                            {
                                if (operands.Remove(leftOperand))
                                {
                                    string name = e.Current.StringValue;

                                    if (hasParameters || (e.MoveNext() && e.Current.Equals('(')))
                                    {
                                        if (e.NextIs(')'))
                                        {
                                            e.MoveNext();
                                            e.MoveNext();
                                            leftOperand.AddWithArgument(name, default(IExpressionOperator));
                                        }
                                        else
                                        {
                                            var args = new ExpressionOperatorCollection(leftOperand);

                                            if (args.Read(e))
                                            {
                                                leftOperand.AddWithArguments(name, args);
                                            }
                                        }

                                        if (hasParameters && e.Current.Equals(')'))
                                        {
                                            e.MoveNext();
                                        }
                                    }
                                    else
                                    {
                                        leftOperand.Add(name);
                                    }

                                    result = leftOperand;
                                }
                            }
                        }
                    }

                    if (result.IsNull())
                    {
                        throw new ExpressionParserException("Invalid keyword '{0}'".FormatInvariant(e.Current.Value), e.Current.Line, e.Current.Position);
                    }
                }
            }

            if (result == null)
            {
                return result;
            }

            result.Component = e.Component;
            return result;
        }
    }
}
