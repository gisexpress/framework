//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2017. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Linq;

namespace System.Runtime
{
    partial class SelectOperator
    {
        partial class DataRecordSet
        {
            protected class TableCollection : Queue<DataTable>
            {
                public TableCollection(IDataSet dataSet, DataRecordSet recordSet)
                {
                    RecordSet = recordSet;
                    Conditions = new List<IExpressionOperator>();

                    if (RecordSet.Operand.From.HasValue())
                    {
                        foreach (IExpressionOperator o in RecordSet.Operand.From)
                        {
                            var join = o as IJoinOperator;

                            if (join == null)
                            {
                                Enqueue(new DataTable(dataSet, o));
                            }
                            else
                            {
                                Enqueue(new DataTable(dataSet, join.Outer));
                                Enqueue(new DataTable(dataSet, join.Inner));

                                Conditions.Add(join.Operand);
                            }
                        }
                    }

                    if (recordSet.Operand.Where == null)
                    {
                        return;
                    }

                    Conditions.Add(recordSet.Operand.Where.Operand);
                }

                readonly DataRecordSet RecordSet;
                List<IExpressionOperator> Conditions;

                public bool TryGetValue(string name, out IDataTable dataSource)
                {
                    foreach (IDataTable item in this)
                    {
                        if (item.Name.EndsWithIgnoreCase(name))
                        {
                            dataSource = item;
                            return true;
                        }
                    }

                    dataSource = null;
                    return true;
                }

                public IEnumerable<IRelationalDataRecord> GetRows()
                {
                    if (Count == 0)
                    {
                        return Enumerable.Repeat(RelationalDataRecord.Empty, 1);
                    }

                    if (Count == 1)
                    {
                        return AsRelational(Dequeue());
                    }

                    return JoinedRows();
                }

                protected IEnumerable<IRelationalDataRecord> JoinedRows()
                {
                    var rows = default(IEnumerable<IRelationalDataRecord>);

                    if (Conditions.Count == 0)
                    {
                        int level, n = 0;

                        while (Count > 0)
                        {
                            level = n;
                            rows = AsRelational(Dequeue()).Join(AsRelationalCopy(Dequeue()), outer => 0, inner => 0, (outer, inner) => Concat(outer, inner, level));
                            n++;
                        }
                    }
                    else
                    {
                        int n = 1, m = 0;
                        var usedTables = new List<IDataTable>();
                        var joinTables = new List<IDataTable>(this);
                        List<JoinPair> pairs = JoinPair.GetJoinPairs(this, Conditions);

                        JoinPair first = pairs.FirstOrDefault();
                        IJoinOperator join = RecordSet.Operand.From.OfType<IJoinOperator>().FirstOrDefault();

                        if (join.HasValue() && join.Type == JoinType.Spatial)
                        {
                            rows = GetSpatialRows(first, (o, i) => Concat(o, i, 0));
                            pairs.Remove(first);
                        }

                        if (first == null)
                        {
                            throw new SyntaxErrorException();
                        }

                        if (rows == null)
                        {
                            rows = AsRelational(first.Outer, first.OuterCriteria).Join(AsRelationalCopy(first.Inner, first.InnerCriteria), outer => first.OuterOperand.Evaluate(outer), inner => first.InnerOperand.Evaluate(inner), (outer, inner) => Concat(outer, inner, 0));
                            pairs.Remove(first);
                        }

                        usedTables.Add(first.Outer);
                        usedTables.Add(first.Inner);

                        joinTables.Remove(first.Outer);
                        joinTables.Remove(first.Inner);

                        while (pairs.Count > m)
                        {
                            int level = n;
                            var current = default(JoinPair);

                            for (int i = 0; i < pairs.Count; i++)
                            {
                                current = pairs[i];

                                if (usedTables.Contains(current.Outer))
                                {
                                    rows = rows.Join(AsRelationalCopy(current.Inner, current.InnerCriteria), outer => current.OuterOperand.Evaluate(outer), inner => current.InnerOperand.Evaluate(inner), (outer, inner) => Concat(outer, inner, level));
                                    break;
                                }
                                else if (usedTables.Contains(current.Inner))
                                {
                                    rows = rows.Join(AsRelationalCopy(current.Outer, current.OuterCriteria), outer => current.InnerOperand.Evaluate(outer), inner => current.OuterOperand.Evaluate(inner), (outer, inner) => Concat(outer, inner, level));
                                    break;
                                }
                                else
                                {
                                    current = default(JoinPair);
                                }
                            }

                            if (current.IsNull())
                            {
                                m++;
                                Debug.Assert(false);
                            }
                            else
                            {
                                pairs.Remove(current);

                                usedTables.Add(current.Outer);
                                usedTables.Add(current.Inner);

                                joinTables.Remove(current.Outer);
                                joinTables.Remove(current.Inner);

                                n++;
                            }
                        }

                        foreach (DataTable item in joinTables)
                        {
                            int level = n;
                            rows = rows.Join(AsRelationalCopy(item), outer => 1, inner => 1, (outer, inner) => Concat(outer, inner, level));
                            n++;
                        }
                    }

                    return rows;
                }

                IEnumerable<IRelationalDataRecord> GetSpatialRows(JoinPair first, Func<IRelationalDataRecord, IRelationalDataRecord, IRelationalDataRecord> resultSelector)
                {
                    var operand = new ValueOperand();
                    var innerRows = first.Inner.GetRows();
                    var criteria = innerRows as ISupportCriteria;

                    if (criteria == null)
                    {
                        yield break;
                    }

                    var outer = AsRelational(first.Outer, first.OuterCriteria);
                    var inner = AsRelationalCopy(first.Inner, first.InnerCriteria, innerRows);

                    foreach (IRelationalDataRecord o in outer)
                    {
                        operand.Value = first.OuterOperand.Evaluate(o);

                        if (criteria.AddCriteria(operand))
                        {
                            foreach (IRelationalDataRecord i in inner)
                            {
                                yield return resultSelector(o, i);
                            }
                        }
                    }
                }

                protected static IRelationalDataRecord Concat(IRelationalDataRecord item, IRelationalDataRecord other, int level)
                {
                    if (item.IsJoined)
                    {
                        item.Rows[level] = other;
                    }
                    else
                    {
                        item.IsJoined = true;
                        item.Rows = item.Rows ?? new IRelationalDataRecord[level + 1];
                        item.Rows[level] = other;
                    }

                    return item;
                }

                protected IEnumerable<IRelationalDataRecord> AsRelational(DataTable dataSource, IExpressionOperator criteria = null, IEnumerable<IDataRecord> e = null)
                {
                    bool criteriaIsNull = criteria == null;
                    var relational = new RelationalDataRecord(dataSource, e ?? (e = dataSource.GetRows()));

                    if (criteriaIsNull && Conditions.Count > 0)
                    {
                        var criteriaSupport = e as ISupportCriteria;

                        if (criteriaSupport.HasValue())
                        {
                            foreach (IExpressionOperator o in Conditions)
                            {
                                criteriaSupport.AddCriteria(o);
                            }
                        }
                    }

                    foreach (IDataRecord r in e)
                    {
                        relational.Row = r;
                        relational.Table = dataSource;

                        if (criteriaIsNull)
                        {
                            yield return relational;
                        }
                        else if (criteria.Validate(relational))
                        {
                            yield return relational;
                        }
                    }
                }

                protected IEnumerable<IRelationalDataRecord> AsRelationalCopy(DataTable dataSource, IExpressionOperator criteria = null, IEnumerable<IDataRecord> e = null)
                {
                    return AsRelational(dataSource, criteria, e).Select(r => r.Clone());
                }
            }
        }
    }
}