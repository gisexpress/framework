//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2017. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;

namespace System.Runtime
{
    internal partial class SelectOperator : ExpressionFunction, ISelectOperator
    {
        static SelectOperator()
        {
            Queries = new Dictionary<int, SelectOperator>();
            ExecuteMethod = typeof(SelectOperator).GetMethod("Execute", BindingFlags.NonPublic | BindingFlags.Static);
        }

        protected static readonly MethodInfo ExecuteMethod;
        protected static readonly Dictionary<int, SelectOperator> Queries;

        public override bool IsEmpty()
        {
            return Fields.IsNull() || Fields.Count == 0;
        }

        public bool Distinct
        {
            get;
            set;
        }

        public override bool IsAggregate()
        {
            return false;
        }

        public override string GetFunctionName()
        {
            return Constants.Sql.KeywordSelect;
        }

        public override bool HasLeftOperand()
        {
            return false;
        }

        public bool IsSubQuery
        {
            get;
            set;
        }

        public override bool IsGroup
        {
            get { return base.IsGroup || Owner.HasValue(); }
            set { base.IsGroup = value; }
        }

        public IRelationalDataRecord ParentRow
        {
            get;
            set;
        }

        public IExpressionOperatorCollection Fields
        {
            get;
            set;
        }

        public IExpressionOperatorCollection From
        {
            get;
            set;
        }

        public IWhereOperator Where
        {
            get;
            set;
        }

        public IOrderOperator OrderBy
        {
            get;
            set;
        }

        public IGroupOperator GroupBy
        {
            get;
            set;
        }

        public override Type ReturnType
        {
            get { return MethodCache.IDataRecordSet; }
        }

        public override bool TryParse(ITokenEnumerator e, IExpressionOperator leftOperand, out IExpressionFunction result)
        {
            var o = new SelectOperator();

            if (ReadFields(o, e))
            {
                if (o.Fields.Count == 0)
                {
                    throw e.SyntaxError();
                }

                if (ReadFrom(o, e))
                {
                    if (o.From.Count == 0)
                    {
                        throw e.SyntaxError();
                    }
                }

                result = o;
                return true;
            }

            result = default(IExpressionFunction);
            return false;
        }

        protected bool ReadFields(SelectOperator operand, ITokenEnumerator e)
        {
            var o = default(IExpressionOperator);
            operand.Fields = OperandFactory.CreateOperatorCollection(operand);

            while (e.CanRead)
            {
                if (e.Current.Equals(Constants.Sql.KeywordDistinct) && e.MoveNext(true))
                {
                    operand.Distinct = true;
                    continue;
                }

                if (e.Current.Equals(','))
                {
                    if (e.MoveNext(true))
                    {
                        o = null;
                    }
                }

                if (e.Current.Equals(Constants.Sql.KeywordFrom))
                {
                    if (operand.Fields.Count > 0)
                    {
                        break;
                    }
                    else
                    {
                        throw e.SyntaxError();
                    }
                }

                if (o.IsNull())
                {
                    if (e.Current.Equals(Constants.Sql.KeywordAsteriskChar))
                    {
                        if (e.MoveNext(true))
                        {
                            operand.Fields.Add(new AsteriskOperand());
                            o = null;
                            continue;
                        }
                    }
                }
                else
                {
                    if (e.Current is WordToken)
                    {
                        var expression = new SelectExpressionOperator(o) { Alias = Read(e, operand.Fields) as IValueOperand };

                        if (expression.Alias.IsNull())
                        {
                            return false;
                        }

                        o.Remove();
                        operand.Fields.Add(expression);
                        o = null;
                        continue;
                    }
                    else if (e.Current.Equals('.') && e.NextIs(Constants.Sql.KeywordAsteriskChar))
                    {
                        if (e.MoveNext(true) && e.MoveNext(true))
                        {
                            o.Remove();
                            operand.Fields.Add(new AsteriskOperand { Operand = o });
                            o = null;
                            continue;
                        }
                    }
                }

                o = Read(e, operand.Fields);
                operand.Fields.Add(o);

                if (e.Current.Equals(Constants.Sql.KeywordAs))
                {
                    if (e.MoveNext(true) && e.Current is WordToken)
                    {
                        var expression = new SelectExpressionOperator(o) { AsKeyword = true, Alias = Read(e, operand.Fields) as IValueOperand };

                        if (expression.Alias.IsNull())
                        {
                            return false;
                        }

                        o.Remove();
                        operand.Fields.Add(expression);
                        o = null;
                        continue;
                    }
                    else
                    {
                        throw e.SyntaxError();
                    }
                }
            }

            return true;
        }

        protected bool ReadFrom(SelectOperator operand, ITokenEnumerator e)
        {
            if (e.Current.Equals(Constants.Sql.KeywordFrom) && e.MoveNext())
            {
                var join = new JoinOperator();
                var o = default(IExpressionOperator);

                operand.From = new FromOperator();

                while (e.CanRead)
                {
                    if (e.Current.Equals(','))
                    {
                        if (e.MoveNext(true))
                        {
                            o = null;
                        }
                    }
                    else if (e.Current.Equals(')'))
                    {
                        break;
                    }

                    if ((join.iType == JoinType.Join && Enum.TryParse<JoinType>(e.Current.StringValue, out join.iType)) || e.Current.Equals(Constants.Sql.KeywordJoin))
                    {
                        if (e.MoveNext(true))
                        {
                            if (e.Current.Equals(Constants.Sql.KeywordJoin))
                            {
                                e.MoveNext(true);
                            }

                            join.Component = e.Component;
                        }
                        else
                        {
                            throw e.SyntaxError();
                        }
                    }

                    if (e.Current.Equals(Constants.Sql.KeywordOn) && e.MoveNext(true))
                    {
                        if (join == null)
                        {
                            throw e.SyntaxError();
                        }

                        var on = default(IExpressionOperator);
                        var operands = new ExpressionOperatorCollection();

                        while (e.CanRead)
                        {
                            operands.Add(on = Read(e, operands));

                            if (e.Current.Any(Constants.Sql.KeywordAnd, Constants.Sql.KeywordOr))
                            {
                                continue;
                            }

                            if (e.Current.Any(Constants.Sql.KeywordWhere))
                            {
                                break;
                            }
                        }

                        join.Operand = on;
                        join.Outer = operand.From.Dequeue();
                        join.Inner = operand.From.Dequeue();
                        operand.From.Add(join);
                        continue;
                    }

                    if (e.Current.Any(Constants.Sql.KeywordWhere, Constants.Sql.KeywordOrder, Constants.Sql.KeywordGroup))
                    {
                        break;
                    }

                    if (o.HasValue())
                    {
                        var expression = new FromExpressionOperator(o) { Alias = Read(e, operand.From) as IValueOperand };

                        if (expression.Alias.IsNull())
                        {
                            return false;
                        }

                        o.Remove();
                        operand.From.Add(expression);
                        o = null;
                        continue;
                    }

                    o = Read(e, operand.From);
                    operand.From.Add(o);

                    if (e.Current.Equals(Constants.Sql.KeywordAs))
                    {
                        if (e.MoveNext(true))
                        {
                            var expression = new FromExpressionOperator(o) { AsKeyword = true, Alias = Read(e, operand.From) as IValueOperand };

                            if (expression.Alias.IsNull())
                            {
                                return false;
                            }

                            o.Remove();
                            operand.From.Add(expression);
                            o = null;
                        }
                    }
                }

                return true;
            }

            return false;
        }

        protected override Type OnPutInstructions(IInstructionEventArgs e)
        {
            int key = GetHashCode();

            if (Queries.ContainsKey(key) == false)
            {
                Queries.Add(key, this);
                Queries.ValidateCapacity(0x1000);
            }

            if (e.ComponentIsNull)
            {
                e.LoadNull();
            }
            else
            {
                e.Generator.Emit(OpCodes.Nop);
                e.Generator.Emit(OpCodes.Ldarg_0);
                e.Generator.Emit(OpCodes.Box, e.ComponentType);
            }

            e.LoadValue(key);
            e.Generator.Emit(OpCodes.Call, ExecuteMethod);

            return ReturnType;
        }

        [Obfuscation(Exclude = true)]
        protected static IDataRecordSet Execute(object component, int key)
        {
            SelectOperator operand;

            if (Queries.TryGetValue(key, out operand))
            {
                var dataSet = component as IDataSet;

                if (dataSet.IsNull())
                {
                    dataSet = ((IRelationalDataRecord)component).DataSet;
                }

                return new DataRecordSet(dataSet, operand);
            }

            return default(IDataRecordSet);
        }

        protected override string OnLegacyToString(ILegacyToStringVisitor visitor)
        {
            string s = GetLegacyStrings(visitor).Join(" ");

            if (IsGroup)
            {
                return string.Concat('(', s, ')');
            }

            return s;
        }

        protected IEnumerable<string> GetLegacyStrings(ILegacyToStringVisitor visitor)
        {
            yield return Constants.Sql.KeywordSelect;

            if (Distinct)
            {
                yield return Constants.Sql.KeywordDistinct;
            }

            yield return Fields.LegacyToString(visitor);

            if (From.HasValue() && From.Count > 0)
            {
                yield return From.LegacyToString(visitor);
            }

            if (Where.HasValue())
            {
                yield return Where.LegacyToString(visitor);
            }

            if (GroupBy.HasValue())
            {
                yield return GroupBy.LegacyToString(visitor);
            }

            if (OrderBy.HasValue())
            {
                yield return OrderBy.LegacyToString(visitor);
            }
        }

        public override IEnumerator<IExpressionOperator> GetEnumerator()
        {
            foreach (IExpressionOperator o in Fields)
            {
                yield return o;
            }

            if (From.HasValue() && From.Count > 0)
            {
                foreach (IExpressionOperator o in From)
                {
                    yield return o;
                }
            }

            if (Where.HasValue())
            {
                yield return Where;
            }

            if (GroupBy.HasValue())
            {
                yield return GroupBy;
            }

            if (OrderBy.HasValue())
            {
                yield return OrderBy;
            }
        }
    }
}
