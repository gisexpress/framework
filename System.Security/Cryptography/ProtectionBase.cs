//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2017. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;

namespace System.Security
{
    [Obfuscation(Exclude = true)]
    internal abstract class ProtectionBase : IProtection
    {
        private static readonly string HexPattern = @"\A\b[0-9a-fA-F]+\b\Z";

        static ProtectionBase()
        {
            Key = GetBytes("5C9E945BA4CF48ABB081C7129CD45EAF");
            SaltBytes = GetBytes("5BFE88D9540E4200ABB4AC1597659651");
        }

        protected static readonly byte[] Key;
        protected static readonly byte[] SaltBytes;

        public byte[] Encrypt(byte[] input)
        {
            return Transform(input, null, false);
        }

        public byte[] Encrypt(byte[] input, byte[] password)
        {
            return Transform(input, password, false);
        }

        public byte[] Encrypt(byte[] input, string password)
        {
            return Transform(input, GetBytes(password), false);
        }

        public string EncryptString(string input)
        {
            return ToHexString(Transform(GetBytes(input), null, false));
        }

        public string EncryptString(string input, string password)
        {
            return ToHexString(Transform(GetBytes(input), GetBytes(password), false));
        }

        public byte[] Decrypt(byte[] input)
        {
            return Transform(input, null, true);
        }

        public byte[] Decrypt(byte[] input, byte[] password)
        {
            return Transform(input, password, true);
        }

        public byte[] Decrypt(byte[] input, string password)
        {
            return Transform(input, GetBytes(password), true);
        }

        public string DecryptString(byte[] input)
        {
            return GetString(Transform(input, null, true));
        }

        public string DecryptString(string input)
        {
            return GetString(Transform(HexStringToByteArray(input), null, true));
        }

        public string DecryptString(string input, string password)
        {
            return GetString(Transform(HexStringToByteArray(input), GetBytes(password), true));
        }

        protected byte[] Transform(byte[] input, byte[] password, bool inverse)
        {
            try
            {
                return OnTransform(input, password, inverse);
            }
            catch
            {
                return null;
            }
        }

        protected abstract byte[] OnTransform(byte[] input, byte[] password, bool inverse);

        protected string GetString(byte[] bytes)
        {
            if (bytes.HasValue() && bytes.Length > 0)
            {
                return new string(Enumerable.Range(0, bytes.Length).Where(x => x % 2 == 0).Select(x => BitConverter.ToChar(bytes, x)).ToArray());
            }

            return null;
        }

        public static byte[] GetBytes(string value)
        {
            return value.ToCharArray().SelectMany(BitConverter.GetBytes).ToArray();
        }

        protected static bool IsHex(string value)
        {
            return !string.IsNullOrEmpty(value) && Regex.IsMatch(value, HexPattern);
        }

        protected internal static string ToHexString(byte[] bytes)
        {
            return BitConverter.ToString(bytes).Replace("-", string.Empty);
        }

        protected internal static byte[] HexStringToByteArray(string hex)
        {
            try
            {
                if (IsHex(hex))
                {
                    return Enumerable.Range(0, hex.Length).Where(x => x % 2 == 0).Select(x => Convert.ToByte(hex.Substring(x, 2), 16)).ToArray();
                }

                return null;
            }
            catch
            {
                return null;
            }
        }

        byte[] IProtection.GetBytes(string value)
        {
            return GetBytes(value);
        }

        string IProtection.GetString(byte[] bytes)
        {
            return GetString(bytes);
        }
    }
}
