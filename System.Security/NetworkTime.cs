//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2017. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Linq;
using System.Net;
using System.Net.Sockets;

namespace System
{
    internal class NetworkTime
    {
#if ReleaseMode
        private static IPAddress NtpHost;
        private readonly static byte ServerReplyTime = 40;
        private readonly static string NtpServer = "time.windows.com";
#endif
        private readonly static DateTime UtcDateTimeMin = new DateTime(1900, 1, 1, 0, 0, 0, DateTimeKind.Utc);

        public static bool GetNetworkTime(out DateTime value)
        {
#if DebugMode
            value = DateTime.Now;
            return true;
#else
            try
            {
                if (NtpHost.IsNull())
                {
                    IAsyncResult r = Dns.BeginGetHostAddresses(NtpServer, default(AsyncCallback), default(object));

                    if (r.AsyncWaitHandle.WaitOne(TimeSpan.FromSeconds(1.0)))
                    {
                        NtpHost = Dns.EndGetHostAddresses(r).FirstOrDefault();
                        string.Concat(NtpServer, " : ", NtpHost).Print();
                    }
                }

                if (NtpHost.HasValue())
                {
                    // NTP message size - 16 bytes of the digest (RFC 2030)
                    var ntpData = new byte[48];

                    //The UDP port number assigned to NTP is 123
                    var ipEndPoint = new IPEndPoint(NtpHost, 123);

                    //NTP uses UDP
                    using (var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp))
                    {
                        //Setting the Leap Indicator, Version Number and Mode values
                        ntpData[0] = 0x1B; //LI = 0 (no warning), VN = 3 (IPv4 only), Mode = 3 (Client Mode)

                        socket.Connect(ipEndPoint);

                        //Stops code hang if NTP is blocked
                        socket.ReceiveTimeout = 3000;
                        socket.Send(ntpData);
                        socket.Receive(ntpData);
                        socket.Close();
                    }

                    //Get the seconds part
                    ulong intPart = BitConverter.ToUInt32(ntpData, ServerReplyTime);

                    //Get the seconds fraction
                    ulong fractPart = BitConverter.ToUInt32(ntpData, ServerReplyTime + 4);

                    //Convert From big-endian to little-endian
                    intPart = SwapEndianness(intPart);
                    fractPart = SwapEndianness(fractPart);

                    value = UtcDateTimeMin.AddMilliseconds((intPart * 1000) + ((fractPart * 1000) / 0x100000000L)).ToLocalTime();

                    if (value.Year >= 2016)
                    {
                        return true;
                    }
                }
            }
            catch (Exception e)
            {
                e.Print();
            }

            value = DateTime.Now;
            return false;
#endif
        }

        static uint SwapEndianness(ulong x)
        {
            return (uint)(((x & 0x000000ff) << 24) + ((x & 0x0000ff00) << 8) + ((x & 0x00ff0000) >> 8) + ((x & 0xff000000) >> 24));
        }
    }
}
