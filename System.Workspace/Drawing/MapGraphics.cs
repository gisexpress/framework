//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Geometries;

namespace System.Workspace.Drawing
{
    public class MapGraphics : IDisposable
    {
        public MapGraphics(MapWorkspace workspace)
        {
            TextEventArgs = new DrawTextEventArgs
            {
                Outline = true,
                Alignment = ContentAlignment.MiddleCenter,
            };

            TextPaths = new Dictionary<DrawTextEventArgs, List<GraphicsPath>>();
            Transform = workspace.Factory.Create<IMapTransform>((Func<IEnvelope>)workspace.GetBounds);
        }

        protected readonly DrawTextEventArgs TextEventArgs;

        public bool IsValid
        {
            get { return Bitmap.Surface.HasValue(); }
        }

        public bool KeepAlive
        {
            get;
            set;
        }

        protected DirectBitmap Bitmap;
        protected readonly Dictionary<DrawTextEventArgs, List<GraphicsPath>> TextPaths;

        public IMapTransform Transform
        {
            get;
            protected set;
        }

        public bool Init(int width, int height)
        {
            if (width > 0 && height > 0)
            {
                if (Transform.ClientWidth != width || Transform.ClientHeight != height)
                {
                    Bitmap.DisposeSafely();

                    if (Transform.Bounds != null)
                    {
                        Transform.ClientWidth = width;
                        Transform.ClientHeight = height;
                        Transform.ZoomToExtent();
                    }

                    Transform.Resize(width, height);
                    Bitmap = new DirectBitmap(width, height);
                }

                return true;
            }

            return false;
        }

        public bool Normalize()
        {
            return Transform.Normalize();
        }

        public bool ZoomToExtent()
        {
            return Transform.ZoomToExtent();
        }

        public bool Zoom(int percent)
        {
            return Transform.Zoom(percent);
        }

        public bool ZoomAt(int percent, PointF point)
        {
            return Transform.ZoomAt(percent, point);
        }

        public bool ZoomTo(RectangleF rect)
        {
            return Transform.ZoomTo(rect);
        }

        public bool ZoomTo(IEnvelope bounds)
        {
            return Transform.ZoomTo(bounds);
        }

        public void Translate(PointF p1, PointF p2)
        {
            Transform.Translate(p1, p2);
        }

        public void Clear()
        {
            Clear(Color.Empty);
        }

        public void Clear(Color color)
        {
            TextPaths.Clear();
            Bitmap.Clear(color);
        }

        public Bitmap Clip(ref IEnvelope bounds)
        {
            if (bounds.IsEmpty())
            {
                return default(Bitmap);
            }

            RectangleF rect = Transform.WorldToClient(bounds);

            if (rect.IsEmpty)
            {
                rect.X -= 10;
                rect.Y -= 10;
                rect.Width = 20;
                rect.Height = 20;
            }

            if (rect.IsEmpty)
            {
                return default(Bitmap);
            }

            rect.X = (int)Math.Ceiling(rect.X);
            rect.Y = (int)Math.Ceiling(rect.Y);
            rect.Width = (int)Math.Floor(rect.Width);
            rect.Height = (int)Math.Floor(rect.Height);

            var img = BitmapExtensions.NewImage(Bitmap.Size.Width, Bitmap.Size.Height);

            using (var g = Graphics.FromImage(img))
            {
                var pageUnit = GraphicsUnit.Pixel;
                RectangleF destRect = img.GetBounds(ref pageUnit);
                g.DrawImage(Bitmap.Image, destRect, rect, pageUnit);
            }

            bounds = Transform.ClientToWorld(rect);
            return img;
        }

        public void Draw(Graphics g)
        {
            Draw(g, 0, 0);
        }

        public void Draw(MapGraphics g)
        {
            if (g.Bitmap.HasValue())
            {
                Bitmap.Surface.DrawImage(g.Bitmap.Image, 0, 0);
            }
        }

        public void Draw(Graphics g, float x, float y)
        {
            if (Bitmap.HasValue())
            {
                g.DrawImage(Bitmap.Image, x, y);
            }
        }

        public void Draw(Image image, int x, int y)
        {
            Bitmap.Surface.DrawImage(image, x, y);
        }

        public void Draw(Image image, float x, float y)
        {
            Bitmap.Surface.DrawImage(image, x, y);
        }

        public void Draw(IGeometry geometry, bool raiseEvents)
        {
            Draw(Bitmap.Surface, geometry, default(PaintStyle), Transform.WorldToClient, raiseEvents);
        }

        public void Draw(IGeometry geometry, PaintStyle style, bool raiseEvents)
        {
            Draw(Bitmap.Surface, geometry, style, Transform.WorldToClient, raiseEvents);
        }

        public void Draw(IGeometry geometry, PaintStyle style, Func<ICoordinate, PointF> transform, bool raiseEvents)
        {
            Draw(Bitmap.Surface, geometry, style, transform, raiseEvents);
        }

        public void Draw(Graphics g, IGeometry geometry, PaintStyle style, bool raiseEvents)
        {
            Draw(g, geometry, style, Transform.WorldToClient, raiseEvents);
        }

        public void Draw(Graphics g, IGeometry geometry, PaintStyle style, Func<ICoordinate, PointF> transform, bool raiseEvents)
        {
            if (geometry == null)
            {
                return;
            }

            foreach (IGeometry item in geometry.GetGeometries())
            {
                if (Transform.Bounds.Intersects(item.GetBounds()))
                {
                    item.Paint(g, style, transform, raiseEvents);
                }
            }
        }

        public DirectBitmap ToImage(bool copy)
        {
            if (copy && Bitmap.HasValue())
            {
                return Bitmap.Clone();
            }

            return Bitmap;
        }

        public MapGraphics Clone()
        {
            var c = (MapGraphics)MemberwiseClone();

            c.Bitmap = new DirectBitmap(Transform.ClientWidth, Transform.ClientHeight);
            c.Transform = Transform.Clone() as IMapTransform;

            return c;
        }

        public void Dispose()
        {
            Transform.DisposeSafely();

            if (!KeepAlive)
            {
                Bitmap.DisposeSafely();
            }

            Transform = null;
            Bitmap = null;

            GC.SuppressFinalize(this);
        }
    }
}
