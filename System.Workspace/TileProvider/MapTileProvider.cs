//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.CoordinateSystems;
using System.Drawing;
using System.Geometries;
using System.Linq;
using System.Net;
using System.Net.Cache;

namespace System.Workspace
{
    public abstract class MapTileProvider
    {
        static MapTileProvider()
        {
            if (DeveloperEnvironment.MSFramework)
            {
                HttpWebRequest.DefaultCachePolicy = new RequestCachePolicy(RequestCacheLevel.CacheIfAvailable);
            }
        }

        protected MapTileProvider(ICoordinateSystem coordinateSystem)
        {
            var bounds = GeometryFactory.Default.Create<IEnvelope>();

            TileSize = 0x100;

            Wgs84 = CoordinateSystemFactory.Create(4326);
            bounds.Init(coordinateSystem.GetDefaultBounds());
            WorldBounds = bounds.Transform(Wgs84.CreateTransform(coordinateSystem));

            Width = WorldBounds.GetWidth();
            Height = WorldBounds.GetHeight();
            CoordinateSystem = coordinateSystem;
        }

        protected ICoordinateSystem Wgs84;

        public int TileSize
        {
            get;
            protected set;
        }

        public double Width
        {
            get;
            protected set;
        }

        public double Height
        {
            get;
            protected set;
        }

        public IEnvelope WorldBounds
        {
            get;
            protected set;
        }

        public ICoordinateSystem CoordinateSystem
        {
            get;
            protected set;
        }

        public double[] GetTileBounds(int x, int y, int level)
        {
            return OnComputeTileBounds(x, y, level).ToArray();
        }

        public IEnumerable<MapTile> GetTiles(IEnvelope bounds, double pixelSize)
        {
            return OnComputeRequiredTiles(bounds, pixelSize).Distinct();
        }

        protected virtual IEnumerable<double> OnComputeTileBounds(int x, int y, int level)
        {
            int n = 1 << level;

            double left, top;
            double w = Width / n;
            double h = Height / n;

            yield return left = WorldBounds.Min.X + x * w;
            yield return left + w;

            yield return top = WorldBounds.Max.Y - y * h;
            yield return top - h;
        }

        protected virtual IEnumerable<MapTile> OnComputeRequiredTiles(IEnvelope bounds, double pixelSize)
        {
            var info = new MapTile(this)
            {
                Size = (int)Math.Ceiling(Height / (TileSize * pixelSize))
            };

            double w = Width / info.Size;
            double h = Height / info.Size;

            for (double y = bounds.Max.Y; y > bounds.Min.Y - h; y -= h)
            {
                info.Y = (int)((WorldBounds.Max.Y - y) / h);

                for (double x = bounds.Min.X; x < bounds.Max.X + w; x += w)
                {
                    info.X = (int)((x - WorldBounds.Min.X) / w);

                    if (info.IsValid)
                    {
                        yield return info;
                    }
                }
            }
        }

        protected abstract string GetDownloadUrl(int x, int y, int level);

        public Bitmap DownloadImage(int x, int y, int level)
        {
            return DownloadImage(GetDownloadUrl(x, y, level));
        }

        public Bitmap DownloadImage(string requestUriString)
        {
            try
            {
                var request = WebRequest.Create(requestUriString) as HttpWebRequest;

                request.KeepAlive = true;
                request.Method = "GET";
                request.Accept = "*/*";
                request.UserAgent = "Mozilla/5.0 (Windows NT 6.1; WOW64) Chrome/48.0.2564.116";

                using (var response = request.GetResponse() as HttpWebResponse)
                {
                    if (response.StatusCode == HttpStatusCode.OK)
                    {
                        return BitmapExtensions.NewImage(Image.FromStream(response.GetResponseStream()));
                    }
                }
            }
            catch (Exception e)
            {
                e.Print();
            }

            return default(Bitmap);
        }
    }
}
